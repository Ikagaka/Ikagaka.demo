// Generated by CoffeeScript 1.8.0
(function() {
  var $, Nar, Promise, Shell, Surface, SurfaceUtil, SurfacesTxt2Yaml, URL, _, _ref, _ref1, _ref2;

  _ = window["_"];

  $ = window["Zepto"];

  SurfacesTxt2Yaml = window["SurfacesTxt2Yaml"];

  Nar = window["Nar"] || ((_ref = window["Ikagaka"]) != null ? _ref["Nar"] : void 0) || require("ikagaka.nar.js");

  Surface = window["Surface"] || ((_ref1 = window["Ikagaka"]) != null ? _ref1["Surface"] : void 0) || require("./Surface.js");

  SurfaceUtil = window["SurfaceUtil"] || ((_ref2 = window["Ikagaka"]) != null ? _ref2["SurfaceUtil"] : void 0) || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  URL = window["URL"];

  Shell = (function() {
    function Shell(directory) {
      if (!directory["descript.txt"]) {
        throw new Error("descript.txt not found");
      }
      this.directory = directory;
      this.descript = null;
      this.surfaces = null;
    }

    Shell.prototype.load = function(callback) {
      var mergedSurfaces, surfaces;
      this.descript = Nar.parseDescript(Nar.convert(this.directory["descript.txt"].asArrayBuffer()));
      if (!!this.directory["surfaces.txt"]) {
        surfaces = Shell.parseSurfaces(Nar.convert(this.directory["surfaces.txt"].asArrayBuffer()));
      } else {
        surfaces = {
          "surfaces": {}
        };
      }
      mergedSurfaces = Shell.mergeSurfacesAndSurfacesFiles(surfaces, this.directory);
      Shell.loadSurfaces(mergedSurfaces, (function(_this) {
        return function(err, loadedSurfaces) {
          return Shell.loadElements(loadedSurfaces, _this.directory, function(err, loadedElmSurfaces) {
            if (!!err) {
              return callback(err);
            }
            _this.surfaces = Shell.createBases(loadedElmSurfaces);
            _this.directory = null;
            return callback(null);
          });
        };
      })(this));
    };

    Shell.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var hit, keys, srfs, type, _ref3, _ref4, _surfaceId;
      type = scopeId === 0 ? "sakura" : "kero";
      if (Array.isArray((_ref3 = this.surfaces.aliases) != null ? (_ref4 = _ref3[type]) != null ? _ref4[surfaceId] : void 0 : void 0)) {
        _surfaceId = SurfaceUtil.choice(this.surfaces.aliases[type][surfaceId]);
      } else {
        _surfaceId = surfaceId;
      }
      srfs = this.surfaces.surfaces;
      keys = Object.keys(srfs);
      hit = keys.find(function(name) {
        return srfs[name].is === _surfaceId;
      });
      if (!hit) {
        return null;
      }
      return new Surface(canvas, scopeId, hit, this.surfaces);
    };

    Shell.createBases = function(surfaces) {
      var keys, srfs;
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      keys.forEach(function(name) {
        var baseSurface, elms, mapped, sortedElms, srfutil, _keys;
        delete srfs[name].file;
        delete srfs[name].base;
        if (!srfs[name].elements) {
          return;
        }
        elms = srfs[name].elements;
        _keys = Object.keys(elms);
        mapped = _keys.map(function(key) {
          return {
            is: elms[key].is,
            x: elms[key].x,
            y: elms[key].y,
            canvas: elms[key].canvas,
            type: elms[key].type
          };
        });
        sortedElms = mapped.sort(function(elmA, elmB) {
          if (elmA.is > elmB.is) {
            return 1;
          } else {
            return -1;
          }
        });
        baseSurface = srfs[name].baseSurface || sortedElms[0].canvas;
        srfutil = new SurfaceUtil(baseSurface);
        srfutil.composeElements(sortedElms);
        srfs[name].baseSurface = baseSurface;
        return delete srfs[name].elements;
      });
      return surfaces;
    };

    Shell.loadSurfaces = function(surfaces, callback) {
      var hits, keys, promises, srfs;
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      hits = keys.filter(function(name) {
        return !!srfs[name].file;
      });
      promises = hits.map(function(name) {
        return new Promise(function(resolve, reject) {
          return setTimeout(function() {
            var buffer, url;
            buffer = srfs[name].file.asArrayBuffer();
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return SurfaceUtil.loadImage(url, function(err, img) {
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err);
              }
              srfs[name].baseSurface = SurfaceUtil.transImage(img);
              return resolve();
            });
          });
        });
      });
      Promise.all(promises).then(function() {
        return callback(null, surfaces);
      })["catch"](function(err) {
        console.error(err, err.stack);
        return callback(err, null);
      });
    };

    Shell.loadElements = function(surfaces, directory, callback) {
      var elmName, hits, keys, promises, srfName, srfs, _i, _j, _keys, _len, _len1;
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      hits = keys.filter(function(name) {
        return !!srfs[name].elements;
      });
      promises = [];
      for (_i = 0, _len = hits.length; _i < _len; _i++) {
        srfName = hits[_i];
        _keys = Object.keys(srfs[srfName].elements);
        for (_j = 0, _len1 = _keys.length; _j < _len1; _j++) {
          elmName = _keys[_j];
          promises.push(new Promise(function(resolve, reject) {
            var elm, file, path, type, x, y;
            elm = srfs[srfName].elements[elmName];
            type = elm.type, file = elm.file, x = elm.x, y = elm.y;
            keys = Object.keys(directory);
            path = keys.find(function(path) {
              var a, b;
              a = path.toLowerCase();
              b = file.toLowerCase();
              return a === b || a === (b + ".png").toLowerCase();
            });
            if (!path) {
              elm.canvas = document.createElement("canvas");
              elm.canvas.width = 1;
              elm.canvas.height = 1;
              resolve();
              return;
            }
            return setTimeout(function() {
              var buffer, url;
              buffer = (directory[path] || directory[path + ".png"]).asArrayBuffer();
              url = URL.createObjectURL(new Blob([buffer], {
                type: "image/png"
              }));
              return SurfaceUtil.loadImage(url, function(err, img) {
                URL.revokeObjectURL(url);
                if (!!err) {
                  return reject(err.error);
                }
                elm.canvas = SurfaceUtil.transImage(img);
                return resolve();
              });
            });
          }));
        }
      }
      Promise.all(promises).then(function() {
        return callback(null, surfaces);
      })["catch"](function(err) {
        console.error(err, err.stack);
        return callback(err, null);
      });
    };

    Shell.mergeSurfacesAndSurfacesFiles = function(surfaces, directory) {
      var file, hits, keys, n, name, srfs, tuples, _i, _len, _ref3;
      srfs = surfaces.surfaces;
      keys = Object.keys(directory);
      hits = keys.filter(function(filename) {
        return /^surface\d+\.png$/i.test(filename);
      });
      tuples = hits.map(function(filename) {
        return [Number((/^surface(\d+)\.png$/i.exec(filename) || ["", "-1"])[1]), directory[filename]];
      });
      for (_i = 0, _len = tuples.length; _i < _len; _i++) {
        _ref3 = tuples[_i], n = _ref3[0], file = _ref3[1];
        name = Object.keys(srfs).find(function(name) {
          return srfs[name].is === n;
        });
        name = name || "surface" + n;
        srfs[name] = srfs[name] || {
          is: n
        };
        srfs[name].file = file;
        srfs[name].baseSurface = document.createElement("canvas");
        srfs[name].baseSurface.width = 0;
        srfs[name].baseSurface.height = 0;
      }
      return surfaces;
    };

    Shell.parseSurfaces = function(text) {
      var keys, srfs, surfaces;
      surfaces = SurfacesTxt2Yaml.txt_to_data(text, {
        compatible: 'ssp-lazy'
      });
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      surfaces.surfaces = keys.reduce((function(obj, name) {
        if (typeof srfs[name].is !== "undefined") {
          obj[name] = srfs[name];
        }
        if (Array.isArray(srfs[name].base)) {
          srfs[name].base.forEach(function(key) {
            return $.extend(true, srfs[name], srfs[key]);
          });
        }
        return obj;
      }), {});
      return surfaces;
    };

    Shell.SurfaceUtil = SurfaceUtil;

    return Shell;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Shell;
  } else if (this.Ikagaka != null) {
    this.Ikagaka.Shell = Shell;
  } else {
    this.Shell = Shell;
  }

}).call(this);
