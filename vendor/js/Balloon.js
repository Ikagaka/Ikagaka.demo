// Generated by CoffeeScript 1.7.1
(function() {
  var $, Balloon, BalloonSurface, Nar, SurfaceUtil, URL, _ref, _ref1, _ref2, _ref3, _ref4;

  $ = window["Zepto"];

  Nar = window["Nar"] || ((_ref = window["Ikagaka"]) != null ? _ref["Nar"] : void 0) || require("ikagaka.nar.js");

  SurfaceUtil = ((_ref1 = this.Shell) != null ? _ref1.SurfaceUtil : void 0) || ((_ref2 = this.Ikagaka) != null ? (_ref3 = _ref2["Shell"]) != null ? _ref3.SurfaceUtil : void 0 : void 0) || require("ikagaka.shell.js").SurfaceUtil;

  BalloonSurface = window["BalloonSurface"] || ((_ref4 = window["Ikagaka"]) != null ? _ref4["BalloonSurface"] : void 0) || require("./BalloonSurface.js");

  URL = window["URL"];

  Balloon = (function() {
    function Balloon(directory) {
      var buffer;
      if (!directory["descript.txt"]) {
        throw new Error("descript.txt not found");
      }
      this.directory = directory;
      buffer = this.directory["descript.txt"].asArrayBuffer();
      this.descript = Nar.parseDescript(Nar.convert(buffer));
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function(callback) {
      Balloon.loadBalloonSurfaces(this.directory, this.balloons, (function(_this) {
        return function(err) {
          Balloon.loadBalloonDescripts(_this.directory, _this.balloons, _this.descript);
          delete _this.directory;
          return callback(err);
        };
      })(this));
    };

    Balloon.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][surfaceId] == null) {
        return null;
      }
      return new BalloonSurface(canvas, scopeId, this.balloons[type][surfaceId], this.balloons);
    };

    Balloon.loadBalloonDescripts = function(directory, balloons, descript) {
      var hits, keys;
      keys = Object.keys(directory);
      hits = keys.filter(function(filepath) {
        return /balloon([sk])(\d+)s\.txt$/.test(filepath);
      });
      hits.forEach(function(filepath) {
        var buffer, n, type, __, _descript, _ref5;
        buffer = directory[filepath].asArrayBuffer();
        _descript = Nar.parseDescript(Nar.convert(buffer));
        _ref5 = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = _ref5[0], type = _ref5[1], n = _ref5[2];
        switch (type) {
          case "s":
            return balloons["sakura"][Number(n)].descript = $.extend(true, _descript, descript);
          case "k":
            return balloons["kero"][Number(n)].descript = $.extend(true, _descript, descript);
        }
      });
      return balloons;
    };

    Balloon.loadBalloonSurfaces = function(directory, balloons, callback) {
      var hits, keys, promises;
      keys = Object.keys(directory);
      hits = keys.filter(function(filepath) {
        return /[^\/]+\.png$/.test(filepath);
      });
      promises = hits.map(function(filepath) {
        return new Promise(function(resolve, reject) {
          return setTimeout(function() {
            var buffer, url;
            buffer = directory[filepath].asArrayBuffer();
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return SurfaceUtil.loadImage(url, function(err, img) {
              var n, type, __, _ref5, _ref6, _ref7;
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err);
              }
              if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
                _ref5 = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = _ref5[0], type = _ref5[1], n = _ref5[2];
                switch (type) {
                  case "s":
                    balloons["sakura"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                    break;
                  case "k":
                    balloons["kero"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                    break;
                  case "c":
                    balloons["communicate"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                }
              } else if (/^online(\d+)\.png$/.test(filepath)) {
                _ref6 = /^online(\d+)\.png$/.exec(filepath), __ = _ref6[0], n = _ref6[1];
                balloons["online"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^arrow(\d+)\.png$/.test(filepath)) {
                _ref7 = /^arrow(\d+)\.png$/.exec(filepath), __ = _ref7[0], n = _ref7[1];
                balloons["arrow"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^sstp\.png$/.test(filepath)) {
                balloons["sstp"] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^thumbnail\.png$/.test(filepath)) {
                balloons["thumbnail"] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              }
              return resolve();
            });
          });
        });
      });
      Promise.all(promises).then(function() {
        return callback(null);
      })["catch"](function(err) {
        console.error(err, err.stack);
        return callback(err);
      });
    };

    return Balloon;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Balloon;
  } else if (this.Ikagaka != null) {
    this.Ikagaka.Balloon = Balloon;
  } else {
    this.Balloon = Balloon;
  }

}).call(this);
