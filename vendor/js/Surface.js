// Generated by CoffeeScript 1.7.1
var Surface;

Surface = (function() {
  var $, Promise, SurfaceUtil, _, _ref;

  $ = window["Zepto"];

  _ = window["_"];

  SurfaceUtil = window["SurfaceUtil"] || ((_ref = window["Ikagaka"]) != null ? _ref["SurfaceUtil"] : void 0) || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  function Surface(element, scopeId, surfaceName, surfaces, callback) {
    var srf;
    this.element = element;
    this.scopeId = scopeId;
    this.surfaceName = surfaceName;
    this.surfaces = surfaces;
    if (callback == null) {
      callback = function() {};
    }
    srf = this.surfaces.surfaces[surfaceName];
    this.baseSurface = srf.baseSurface;
    this.regions = srf.regions || {};
    this.animations = srf.animations || {};
    this.bufferCanvas = SurfaceUtil.copy(this.baseSurface);
    this.stopFlags = {};
    this.layers = {};
    this.destructed = false;
    this.talkCount = 0;
    this.talkCounts = {};
    this.isPointerEventsShimed = false;
    this.lastEventType = "";
    $(this.element).on("contextmenu", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("click", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("dblclick", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseDoubleClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousedown", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseDown", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousemove", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mouseup", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchmove", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchend", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchstart", (function(_this) {
      return function() {
        var touchOnce;
        touchOnce = false;
        return function(ev) {
          touchOnce = !touchOnce;
          if (touchOnce) {
            Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
              return $(_this.element).trigger($ev);
            });
            return setTimeout((function() {
              return touchOnce = false;
            }), 500);
          }
        };
      };
    })(this)());
    Object.keys(this.animations).forEach((function(_this) {
      return function(name) {
        var animationId, interval, n, pattern, tmp, _is, _ref1;
        _ref1 = _this.animations[name], _is = _ref1.is, interval = _ref1.interval, pattern = _ref1.pattern;
        animationId = _is;
        interval = interval || "";
        tmp = interval.split(",");
        interval = tmp[0];
        n = Number(tmp.slice(1).join(","));
        switch (interval) {
          case "sometimes":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 2);
          case "rarely":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 4);
          case "random":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "periodic":
            return Surface.periodic((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "always":
            return Surface.always(function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            });
          case "runonce":
            return _this.play(animationId, callback);
          case "never":
            break;
          case "bind":
            break;
          case "yen-e":
            break;
          case "talk":
            return _this.talkCounts[name] = n;
          default:
            if (/^bind(?:\+(\d+))/.test(interval)) {

            }
            return console.error(_this.animations[name]);
        }
      };
    })(this));
    this.render();
  }

  Surface.prototype.destructor = function() {
    SurfaceUtil.clear(this.element);
    $(this.element).off();
    this.destructed = true;
    this.layers = {};
    return void 0;
  };

  Surface.prototype.YenE = function() {
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].interval === "yen-e" && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(_this.animations[name].is);
      };
    })(this));
  };

  Surface.prototype.talk = function() {
    this.talkCount++;
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return /^talk/.test(_this.animations[name].interval) && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(_this.animations[name].is);
      };
    })(this));
  };

  Surface.prototype.render = function() {
    var patterns, srfs, util, util2;
    srfs = this.surfaces.surfaces;
    patterns = Object.keys(this.layers).sort(function(layerNumA, layerNumB) {
      if (Number(layerNumA) > Number(layerNumB)) {
        return 1;
      } else {
        return -1;
      }
    }).map((function(_this) {
      return function(key) {
        return _this.layers[key];
      };
    })(this)).reduce(((function(_this) {
      return function(arr, pat) {
        var hits, surface, type, x, y;
        surface = pat.surface, type = pat.type, x = pat.x, y = pat.y;
        if (surface === -1) {
          return arr;
        }
        hits = Object.keys(srfs).filter(function(key) {
          return srfs[key].is === surface;
        });
        if (hits.length === 0) {
          return arr;
        }
        return arr.concat({
          type: type,
          x: x,
          y: y,
          canvas: srfs[hits[hits.length - 1]].baseSurface
        });
      };
    })(this)), []);
    SurfaceUtil.clear(this.bufferCanvas);
    util = new SurfaceUtil(this.bufferCanvas);
    util.composeElements([
      {
        "type": "base",
        "canvas": this.baseSurface
      }
    ].concat(patterns));
    SurfaceUtil.clear(this.element);
    util2 = new SurfaceUtil(this.element);
    util2.init(this.bufferCanvas);
    return void 0;
  };

  Surface.prototype.play = function(animationId, callback) {
    var anim, hits;
    if (callback == null) {
      callback = function() {};
    }
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].is === animationId;
      };
    })(this));
    if (hits.length === 0) {
      setTimeout(callback);
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    anim.patterns.map((function(_this) {
      return function(pattern) {
        return function() {
          return new Promise(function(resolve, reject) {
            var a, animId, arr, b, match, surface, type, wait, __, _ref1, _ref2, _ref3;
            surface = pattern.surface, wait = pattern.wait, type = pattern.type;
            if (/^start\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.play(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^stop\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.stop(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^alternativestart\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref1 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref1[0], match = _ref1[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.play(animId, function() {
                  return resolve();
                });
                return;
              }
            }
            if (/^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref2 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref2[0], match = _ref2[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.stop(animId);
                resolve();
                return;
              }
            }
            _this.layers[anim.is] = pattern;
            _this.render();
            _ref3 = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref3[0], a = _ref3[1], b = _ref3[2];
            if (!!b) {
              wait = _.random(Number(a), Number(b));
            }
            return setTimeout((function() {
              if (_this.destructed) {
                return reject();
              } else {
                return resolve();
              }
            }), wait);
          });
        };
      };
    })(this)).reduce((function(proA, proB) {
      return proA.then(proB);
    }), Promise.resolve()).then((function(_this) {
      return function() {
        return setTimeout(callback);
      };
    })(this))["catch"](function(err) {
      return console.error(err.stack);
    });
    return void 0;
  };

  Surface.prototype.stop = function(animationId) {
    this.stopFlags[animationId] = true;
    return void 0;
  };

  Surface.prototype.bind = function(animationId) {
    var anim, animIds, hits, interval, pattern;
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].is === animationId;
      };
    })(this));
    if (hits.length === 0) {
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    if (anim.patterns.length === 0) {
      return void 0;
    }
    interval = anim.interval;
    pattern = anim.patterns[anim.patterns.length - 1];
    this.layers[anim.is] = pattern;
    this.render();
    if (/^bind(?:\+(\d+))/.test(interval)) {
      animIds = interval.split("+").slice(1);
      animIds.forEach((function(_this) {
        return function(animId) {
          return _this.play(animId, function() {});
        };
      })(this));
    }
    return void 0;
  };

  Surface.prototype.unbind = function(animationId) {
    delete this.layers[animationId];
    return void 0;
  };

  Surface.prototype.processMouseEvent = function(ev, eventName, callback) {
    var detail, elm, hits, left, offsetX, offsetY, pageX, pageY, top, _ev, _ref1, _ref2;
    ev.preventDefault();
    $(ev.target).css({
      "cursor": "default"
    });
    if (this.isPointerEventsShimed && ev.type === this.lastEventType) {
      this.lastEventType = "";
      this.isPointerEventsShimed = false;
      ev.stopPropagation();
      return;
    }
    if (/^touch/.test(ev.type)) {
      _ref1 = ev.changedTouches[0], pageX = _ref1.pageX, pageY = _ref1.pageY;
    } else {
      pageX = ev.pageX, pageY = ev.pageY;
    }
    _ref2 = $(ev.target).offset(), left = _ref2.left, top = _ref2.top;
    offsetX = pageX - left;
    offsetY = pageY - top;
    if (Surface.isHit(ev.target, offsetX, offsetY)) {
      detail = {
        "ID": eventName,
        "Reference0": offsetX | 0,
        "Reference1": offsetY | 0,
        "Reference2": 0,
        "Reference3": this.scopeId,
        "Reference4": "",
        "Reference5": (ev.button === 2 ? 1 : 0)
      };
      hits = Object.keys(this.regions).sort(function(a, b) {
        if (a.is > b.is) {
          return 1;
        } else {
          return -1;
        }
      }).filter((function(_this) {
        return function(name) {
          var bottom, right, _ref3;
          _ref3 = _this.regions[name], name = _ref3.name, left = _ref3.left, top = _ref3.top, right = _ref3.right, bottom = _ref3.bottom;
          return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
        };
      })(this));
      if (hits.length !== 0) {
        detail["Reference4"] = this.regions[hits[hits.length - 1]].name;
        $(ev.target).css({
          "cursor": "pointer"
        });
      }
      callback($.Event('IkagakaSurfaceEvent', {
        detail: detail,
        bubbles: true
      }));
    } else {
      ev.stopPropagation();
      this.isPointerEventsShimed = true;
      this.lastEventType = ev.type;
      $(ev.target).css({
        display: 'none'
      });
      elm = document.elementFromPoint(pageX, pageY);
      $(ev.target).css({
        display: 'inline-block'
      });
      _ev = document.createEvent(ev.constructor.name);
      if (typeof _ev.initMouseEvent === "function") {
        _ev.initMouseEvent(ev.type, ev.bubbles, ev.cancelable, ev.view, ev.detail, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, ev.button, ev.relatedTarget);
      }
      elm.dispatchEvent(_ev);
    }
    return void 0;
  };

  Surface.random = function(callback, n) {
    var ms;
    ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / n) {
      ms++;
    }
    return setTimeout((function() {
      return callback(function() {
        return Surface.random(callback, n);
      });
    }), ms * 1000);
  };

  Surface.periodic = function(callback, n) {
    return setTimeout((function() {
      return callback(function() {
        return Surface.periodic(callback, n);
      });
    }), n * 1000);
  };

  Surface.always = function(callback) {
    return callback(function() {
      return Surface.always(callback);
    });
  };

  Surface.isHit = function(canvas, x, y) {
    var ctx, data, imgdata;
    ctx = canvas.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
    data = imgdata.data;
    return data[data.length - 1] !== 0;
  };

  return Surface;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Surface;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Surface"] = Surface;
}
