// Generated by CoffeeScript 1.7.1
(function() {
  var $, Promise, Surface, SurfaceUtil, _, _ref;

  $ = this.Zepto;

  _ = this._;

  SurfaceUtil = this.SurfaceUtil || ((_ref = this.Ikagaka) != null ? _ref["SurfaceUtil"] : void 0) || require("./SurfaceUtil.js");

  Promise = this.Promise;

  Surface = (function() {
    function Surface(element, scopeId, surfaceName, surfaces) {
      var keys, srf;
      this.element = element;
      this.scopeId = scopeId;
      this.surfaceName = surfaceName;
      this.surfaces = surfaces;
      srf = this.surfaces.surfaces[surfaceName];
      this.baseSurface = srf.baseSurface;
      this.regions = srf.regions || {};
      this.animations = srf.animations || {};
      this.bufferCanvas = SurfaceUtil.copy(this.baseSurface);
      this.stopFlags = {};
      this.layers = {};
      this.destructed = false;
      this.talkCount = 0;
      this.talkCounts = {};
      this.isPointerEventsShimed = false;
      this.lastEventType = "";
      $(this.element).on("contextmenu", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("click", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("dblclick", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseDoubleClick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mousedown", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseDown", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mousemove", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mouseup", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("touchmove", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("touchend", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("touchstart", (function(_this) {
        return function() {
          var touchOnce;
          touchOnce = false;
          return function(ev) {
            touchOnce = !touchOnce;
            if (touchOnce) {
              Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
                return $(_this.element).trigger($ev);
              });
              return setTimeout((function() {
                return touchOnce = false;
              }), 500);
            }
          };
        };
      })(this)());
      keys = Object.keys(this.animations);
      keys.forEach((function(_this) {
        return function(name) {
          var animationId, interval, n, pattern, tmp, _is, _ref1;
          _ref1 = _this.animations[name], _is = _ref1.is, interval = _ref1.interval, pattern = _ref1.pattern;
          animationId = _is;
          interval = interval || "";
          tmp = interval.split(",");
          interval = tmp[0];
          n = Number(tmp.slice(1).join(","));
          switch (interval) {
            case "sometimes":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), 2);
            case "rarely":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), 4);
            case "random":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), n);
            case "periodic":
              return Surface.periodic((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), n);
            case "always":
              return Surface.always(function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              });
            case "runonce":
              return _this.play(animationId);
            case "never":
              break;
            case "bind":
              break;
            case "yen-e":
              break;
            case "talk":
              return _this.talkCounts[name] = n;
            default:
              if (/^bind(?:\+(\d+))/.test(interval)) {

              }
              return console.error(_this.animations[name]);
          }
        };
      })(this));
      this.render();
    }

    Surface.prototype.destructor = function() {
      SurfaceUtil.clear(this.element);
      $(this.element).off();
      this.destructed = true;
      this.layers = {};
    };

    Surface.prototype.yenE = function() {
      var hits, keys;
      keys = Object.keys(this.animations);
      hits = keys.filter((function(_this) {
        return function(name) {
          return _this.animations[name].interval === "yen-e" && _this.talkCount % _this.talkCounts[name] === 0;
        };
      })(this));
      hits.forEach((function(_this) {
        return function(name) {
          return _this.play(_this.animations[name].is);
        };
      })(this));
    };

    Surface.prototype.talk = function() {
      var hits, keys;
      this.talkCount++;
      keys = Object.keys(this.animations);
      hits = keys.filter((function(_this) {
        return function(name) {
          return /^talk/.test(_this.animations[name].interval) && _this.talkCount % _this.talkCounts[name] === 0;
        };
      })(this));
      hits.forEach((function(_this) {
        return function(name) {
          return _this.play(_this.animations[name].is);
        };
      })(this));
    };

    Surface.prototype.render = function() {
      var keys, mapped, patterns, sorted, srfs, util, util2;
      srfs = this.surfaces.surfaces;
      keys = Object.keys(this.layers);
      sorted = keys.sort(function(layerNumA, layerNumB) {
        if (Number(layerNumA) > Number(layerNumB)) {
          return 1;
        } else {
          return -1;
        }
      });
      mapped = sorted.map((function(_this) {
        return function(key) {
          return _this.layers[key];
        };
      })(this));
      patterns = mapped.reduce(((function(_this) {
        return function(arr, pat) {
          var hit, surface, type, x, y;
          surface = pat.surface, type = pat.type, x = pat.x, y = pat.y;
          if (surface === -1) {
            return arr;
          }
          keys = Object.keys(srfs);
          hit = keys.find(function(key) {
            return srfs[key].is === surface;
          });
          if (!hit === 0) {
            return arr;
          }
          return arr.concat({
            type: type,
            x: x,
            y: y,
            canvas: srfs[hit].baseSurface
          });
        };
      })(this)), []);
      SurfaceUtil.clear(this.bufferCanvas);
      util = new SurfaceUtil(this.bufferCanvas);
      util.composeElements([
        {
          "type": "base",
          "canvas": this.baseSurface
        }
      ].concat(patterns));
      SurfaceUtil.clear(this.element);
      util2 = new SurfaceUtil(this.element);
      util2.init(this.bufferCanvas);
    };

    Surface.prototype.play = function(animationId, callback) {
      var anim, hit, keys, lazyPromises, promise;
      if (callback == null) {
        callback = function() {};
      }
      keys = Object.keys(this.animations);
      hit = keys.find((function(_this) {
        return function(name) {
          return _this.animations[name].is === animationId;
        };
      })(this));
      if (!hit) {
        setTimeout(callback);
        return;
      }
      anim = this.animations[hit];
      lazyPromises = anim.patterns.map((function(_this) {
        return function(pattern) {
          return function() {
            return new Promise(function(resolve, reject) {
              var a, animId, arr, b, match, surface, type, wait, __, _ref1, _ref2, _ref3;
              surface = pattern.surface, wait = pattern.wait, type = pattern.type;
              if (/^start\,\d+/.test(type)) {
                animId = Number(type.split(",")[1]);
                _this.play(animId, function() {
                  return resolve();
                });
                return;
              }
              if (/^stop\,\d+/.test(type)) {
                animId = Number(type.split(",")[1]);
                _this.stop(animId, function() {
                  return resolve();
                });
                return;
              }
              if (/^alternativestart\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
                _ref1 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref1[0], match = _ref1[1];
                arr = match.split(/[\,\.]/);
                if (arr.length > 0) {
                  animId = Number(SurfaceUtil.choice(arr));
                  _this.play(animId, function() {
                    return resolve();
                  });
                  return;
                }
              }
              if (/^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
                _ref2 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref2[0], match = _ref2[1];
                arr = match.split(/[\,\.]/);
                if (arr.length > 0) {
                  animId = Number(SurfaceUtil.choice(arr));
                  _this.stop(animId);
                  resolve();
                  return;
                }
              }
              _this.layers[anim.is] = pattern;
              _this.render();
              _ref3 = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref3[0], a = _ref3[1], b = _ref3[2];
              if (!!b) {
                wait = _.random(Number(a), Number(b));
              }
              return setTimeout((function() {
                if (_this.destructed) {
                  return reject();
                } else {
                  return resolve();
                }
              }), wait);
            });
          };
        };
      })(this));
      promise = lazyPromises.reduce((function(proA, proB) {
        return proA.then(proB);
      }), Promise.resolve());
      promise.then((function(_this) {
        return function() {
          return setTimeout(callback);
        };
      })(this))["catch"](function(err) {
        if (!!err) {
          return console.error(err.stack);
        }
      });
    };

    Surface.prototype.stop = function(animationId) {
      this.stopFlags[animationId] = true;
    };

    Surface.prototype.bind = function(animationId) {
      var anim, animIds, hit, interval, keys, pattern;
      keys = Object.keys(this.animations);
      hit = keys.find((function(_this) {
        return function(name) {
          return _this.animations[name].is === animationId;
        };
      })(this));
      if (hit) {
        return void 0;
      }
      anim = this.animations[hit];
      if (anim.patterns.length === 0) {
        return void 0;
      }
      interval = anim.interval;
      pattern = anim.patterns[anim.patterns.length - 1];
      this.layers[anim.is] = pattern;
      this.render();
      if (/^bind(?:\+(\d+))/.test(interval)) {
        animIds = interval.split("+").slice(1);
        animIds.forEach((function(_this) {
          return function(animId) {
            return _this.play(animId, function() {});
          };
        })(this));
      }
    };

    Surface.prototype.unbind = function(animationId) {
      delete this.layers[animationId];
    };

    Surface.prototype.processMouseEvent = function(ev, eventName, callback) {
      var detail, elm, hit, keys, left, offsetX, offsetY, pageX, pageY, sorted, top, _ev, _ref1, _ref2;
      ev.preventDefault();
      $(ev.target).css({
        "cursor": "default"
      });
      if (this.isPointerEventsShimed && ev.type === this.lastEventType) {
        this.lastEventType = "";
        this.isPointerEventsShimed = false;
        ev.stopPropagation();
        return;
      }
      if (/^touch/.test(ev.type)) {
        _ref1 = ev.changedTouches[0], pageX = _ref1.pageX, pageY = _ref1.pageY;
      } else {
        pageX = ev.pageX, pageY = ev.pageY;
      }
      _ref2 = $(ev.target).offset(), left = _ref2.left, top = _ref2.top;
      offsetX = pageX - left;
      offsetY = pageY - top;
      if (Surface.isHit(ev.target, offsetX, offsetY)) {
        detail = {
          "ID": eventName,
          "Reference0": offsetX | 0,
          "Reference1": offsetY | 0,
          "Reference2": 0,
          "Reference3": this.scopeId,
          "Reference4": "",
          "Reference5": (ev.button === 2 ? 1 : 0)
        };
        keys = Object.keys(this.regions);
        sorted = keys.sort(function(a, b) {
          if (a.is > b.is) {
            return 1;
          } else {
            return -1;
          }
        });
        hit = sorted.find((function(_this) {
          return function(name) {
            var bottom, right, _ref3;
            _ref3 = _this.regions[name], name = _ref3.name, left = _ref3.left, top = _ref3.top, right = _ref3.right, bottom = _ref3.bottom;
            return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
          };
        })(this));
        if (!!hit) {
          detail["Reference4"] = this.regions[hit].name;
          $(ev.target).css({
            "cursor": "pointer"
          });
        }
        callback($.Event('IkagakaSurfaceEvent', {
          detail: detail,
          bubbles: true
        }));
      } else {
        ev.stopPropagation();
        this.isPointerEventsShimed = true;
        this.lastEventType = ev.type;
        $(ev.target).css({
          display: 'none'
        });
        elm = document.elementFromPoint(pageX, pageY);
        if (!elm) {
          return;
        }
        $(ev.target).css({
          display: 'inline-block'
        });
        _ev = document.createEvent(ev.constructor.name);
        if (typeof _ev.initMouseEvent === "function") {
          _ev.initMouseEvent(ev.type, ev.bubbles, ev.cancelable, ev.view, ev.detail, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, ev.button, ev.relatedTarget);
        }
        elm.dispatchEvent(_ev);
      }
    };

    Surface.random = function(callback, n) {
      var ms;
      ms = 1;
      while (Math.round(Math.random() * 1000) > 1000 / n) {
        ms++;
      }
      setTimeout((function() {
        return callback(function() {
          return Surface.random(callback, n);
        });
      }), ms * 1000);
    };

    Surface.periodic = function(callback, n) {
      setTimeout((function() {
        return callback(function() {
          return Surface.periodic(callback, n);
        });
      }), n * 1000);
    };

    Surface.always = function(callback) {
      callback(function() {
        return Surface.always(callback);
      });
    };

    Surface.isHit = function(canvas, x, y) {
      var ctx, data, imgdata;
      ctx = canvas.getContext("2d");
      imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
      data = imgdata.data;
      return data[data.length - 1] !== 0;
    };

    return Surface;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Surface;
  } else if (this.Ikagaka != null) {
    this.Ikagaka.Surface = Surface;
  } else {
    this.Surface = Surface;
  }

}).call(this);
