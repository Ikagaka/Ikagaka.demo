// Generated by CoffeeScript 1.9.2

/* (C) 2015 Legokichi : Licensed under The MIT License */

(function() {
  var global;

  global = (this || 0).self || global;

  global["cuttlebone"] = {};

  cuttlebone.Util = {
    convert: function(buffer) {
      return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
    },
    parseDescript: function (text){
    // @arg String
    // @ret {[id: String]: String;}
    text = text.replace(/(?:\r\n|\r|\n)/g, "\n"); // CRLF->LF
    while(true){// remove commentout
      var match = (/(?:(?:^|\s)\/\/.*)|^\s+?$/g.exec(text) || ["",""])[0];
      if(match.length === 0) break;
      text = text.replace(match, "");
    }
    var lines = text.split("\n");
    lines = lines.filter(function(line){ return line.length !== 0; }); // remove no content line
    var dic = lines.reduce(function(dic, line){
      var tmp = line.split(",");
      var key = tmp[0];
      var vals = tmp.slice(1);
      key = key.trim();
      var val = vals.join(",").trim();
      dic[key] = val;
      return dic;
    }, {});
    return dic;
  }
  };

}).call(this);
// Generated by CoffeeScript 1.9.2
(function() {
  cuttlebone.NamedManager = (function() {
    function NamedManager() {
      var $style;
      this.$namedMgr = $("<div />").addClass("namedMgr");
      $style = $("<style scoped />").html(this.style);
      this.$namedMgr.append($style);
      this.element = this.$namedMgr[0];
      this.namedies = [];
      this.destructors = [];
      (function(_this) {
        return (function() {
          var onmousedown;
          onmousedown = function(ev) {
            return setTimeout((function() {
              return _this.$namedMgr.append(ev.currentTarget);
            }), 300);
          };
          _this.$namedMgr.on("mousedown", ".named", onmousedown);
          _this.$namedMgr.on("touchstart", ".named", onmousedown);
          return _this.destructors.push(function() {
            _this.$namedMgr.off("mousedown", ".named", onmousedown);
            return _this.$namedMgr.off("touchstart", ".named", onmousedown);
          });
        });
      })(this)();
    }

    NamedManager.prototype.destructor = function() {
      this.namedies.filter(function(named) {
        return named != null;
      }).forEach(function(named) {
        return $(named.element).remove();
      });
      this.destructors.forEach(function(destructor) {
        return destructor();
      });
      this.$namedMgr.remove();
    };

    NamedManager.prototype.materialize = function(shell, balloon) {
      var named;
      named = new cuttlebone.Named(shell, balloon);
      this.namedies.push(named);
      this.$namedMgr.append(named.element);
      return this.namedies.length - 1;
    };

    NamedManager.prototype.vanish = function(namedId) {
      if (this.namedies[namedId] == null) {
        throw new Error("namedId " + namedId + " is not used yet");
      }
      this.namedies[namedId].destructor();
      this.namedies[namedId] = null;
    };

    NamedManager.prototype.named = function(namedId) {
      if (this.namedies[namedId] == null) {
        throw new Error("namedId " + namedId + " is not used yet");
      }
      return this.namedies[namedId];
    };

    NamedManager.prototype.style = ".scope {\n  position: absolute;\n  pointer-events: none;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n.surface {\n}\n.surfaceCanvas {\n  pointer-events: auto;\n}\n.blimp {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  pointer-events: auto;\n}\n.blimpCanvas {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.blimpText {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow-y: scroll;\n  white-space: pre-wrap;\n  word-wrap: break-all;\n}\n.blimpText a {\n  cursor: pointer;\n}\n\n@keyframes blink {\n  75% { opacity: 0.0; }\n}\n.blink {\n  animation: blink 1s step-end infinite;\n}";

    return NamedManager;

  })();

}).call(this);
// Generated by CoffeeScript 1.9.2
(function() {
  var slice = [].slice;

  cuttlebone.Named = (function() {
    function Named(shell, balloon) {
      this.shell = shell;
      this.balloon = balloon;
      this.$named = $("<div />").addClass("named");
      this.element = this.$named[0];
      this.scopes = [];
      this.currentScope = null;
      this.destructors = [];
      this.listener = {};
    }

    Named.prototype.load = function() {
      this.scopes[0] = this.scope(0);
      this.currentScope = this.scopes[0];
      $(this.element).on("IkagakaDOMEvent", (function(_this) {
        return function(arg) {
          var event;
          event = arg.detail;
          return _this.trigger(event.type, event);
        };
      })(this));
      (function(_this) {
        return (function() {
          var $body, $target, onmousedown, onmousemove, onmouseup, relLeft, relTop;
          $target = null;
          relLeft = relTop = 0;
          onmouseup = function(ev) {
            var ref, ref1;
            if (!!$target) {
              if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
                if ($target[0] === ((ref = $(ev.target).parent()) != null ? ref[0] : void 0)) {
                  return $target = null;
                }
              } else if ($(ev.target).hasClass("surfaceCanvas")) {
                if ($target[0] === ((ref1 = $(ev.target).parent().parent()) != null ? ref1[0] : void 0)) {
                  return $target = null;
                }
              }
            }
          };
          onmousedown = function(ev) {
            var $scope, left, offsetX, offsetY, pageX, pageY, ref, ref1, ref2, ref3, top;
            if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
              if (((ref = $(ev.target).parent().parent().parent()) != null ? ref[0] : void 0) === _this.element) {
                $target = $(ev.target).parent();
                $scope = $target.parent();
                ref1 = $target.offset(), top = ref1.top, left = ref1.left;
                offsetY = parseInt($target.css("left"), 10);
                offsetX = parseInt($target.css("top"), 10);
                if (/^touch/.test(ev.type)) {
                  pageX = ev.touches[0].pageX;
                  pageY = ev.touches[0].pageY;
                } else {
                  pageX = ev.pageX;
                  pageY = ev.pageY;
                }
                relLeft = pageX - offsetY;
                relTop = pageY - offsetX;
                return setTimeout((function() {
                  return _this.$named.append($scope);
                }), 200);
              }
            } else if ($(ev.target).hasClass("surfaceCanvas")) {
              if (((ref2 = $(ev.target).parent().parent().parent()) != null ? ref2[0] : void 0) === _this.element) {
                $scope = $target = $(ev.target).parent().parent();
                ref3 = $target.offset(), top = ref3.top, left = ref3.left;
                if (/^touch/.test(ev.type)) {
                  pageX = ev.touches[0].pageX;
                  pageY = ev.touches[0].pageY;
                } else {
                  pageX = ev.pageX;
                  pageY = ev.pageY;
                }
                relLeft = pageX - left;
                relTop = pageY - top;
                return setTimeout((function() {
                  return _this.$named.append($scope);
                }), 200);
              }
            }
          };
          onmousemove = function(ev) {
            var pageX, pageY;
            if (!!$target) {
              if (/^touch/.test(ev.type)) {
                pageX = ev.touches[0].pageX;
                pageY = ev.touches[0].pageY;
              } else {
                pageX = ev.pageX;
                pageY = ev.pageY;
              }
              return $target.css({
                left: pageX - relLeft,
                top: pageY - relTop
              });
            }
          };
          $body = $("body");
          $body.on("mousedown", onmousedown);
          $body.on("mousemove", onmousemove);
          $body.on("mouseup", onmouseup);
          $body.on("touchstart", onmousedown);
          $body.on("touchmove", onmousemove);
          $body.on("touchend", onmouseup);
          return _this.destructors.push(function() {
            $body.off("mousedown", onmousedown);
            $body.off("mousemove", onmousemove);
            $body.off("mouseup", onmouseup);
            $body.off("touchstart", onmousedown);
            $body.off("touchmove", onmousemove);
            return $body.off("touchend", onmouseup);
          });
        });
      })(this)();
      (function(_this) {
        return (function() {
          var onblimpclick, onblimpdblclick;
          onblimpclick = function(ev) {
            var event;
            event = {
              type: "balloonclick"
            };
            return _this.trigger(event.type, event);
          };
          onblimpdblclick = function(ev) {
            var event;
            event = {
              type: "balloondblclick"
            };
            return _this.trigger(event.type, event);
          };
          _this.$named.on("click", ".blimp", onblimpclick);
          _this.$named.on("dblclick", ".blimp", onblimpdblclick);
          return _this.destructors.push(function() {
            _this.$named.off("click", ".blimp", onblimpclick);
            return _this.$named.off("dblclick", ".blimp", onblimpdblclick);
          });
        });
      })(this)();
      (function(_this) {
        return (function() {
          var onanchorclick, onchoiceclick;
          onchoiceclick = function(ev) {
            var argc, event, i, j, ref;
            event = {};
            event.type = "choiceselect";
            event.id = ev.target.dataset["id"];
            event.args = [];
            event.text = ev.target.textContent;
            argc = Number(ev.target.dataset["argc"]);
            for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              event.args.push(ev.target.dataset["argv" + i]);
            }
            return _this.trigger(event.type, event);
          };
          onanchorclick = function(ev) {
            var argc, event, i, j, ref;
            event = {};
            event.type = "anchorselect";
            event.id = ev.target.dataset["id"];
            event.args = [];
            event.text = ev.target.textContent;
            argc = Number(ev.target.dataset["argc"]);
            for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              event.args.push(ev.target.dataset["argv" + i]);
            }
            return _this.trigger(event.type, event);
          };
          _this.$named.on("click", ".ikagaka-choice", onchoiceclick);
          _this.$named.on("click", ".ikagaka-anchor", onanchorclick);
          return _this.destructors.push(function() {
            _this.$named.off("click", ".ikagaka-choice", onchoiceclick);
            return _this.$named.off("click", ".ikagaka-anchor", onanchorclick);
          });
        });
      })(this)();
      return Promise.resolve(this);
    };

    Named.prototype.destructor = function() {
      this.scopes.forEach(function(scope) {
        return $(scope.element).remove();
      });
      this.destructors.forEach(function(destructor) {
        return destructor();
      });
      this.$named.remove();
    };

    Named.prototype.scope = function(scopeId) {
      if (!isFinite(scopeId)) {
        return this.currentScope;
      }
      if (!this.scopes[scopeId]) {
        this.scopes[scopeId] = new cuttlebone.Scope(scopeId, this.shell, this.balloon);
      }
      this.currentScope = this.scopes[scopeId];
      this.$named.append(this.scopes[scopeId].element);
      return this.currentScope;
    };

    Named.prototype.openInputBox = function(id, text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "userinput",
        "id": id,
        "content": prompt("UserInput", text)
      };
      this.trigger(event.type, event);
    };

    Named.prototype.openCommunicateBox = function(text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "communicateinput",
        "sender": "user",
        "content": prompt("Communicate", text)
      };
      this.trigger(event.type, event);
    };

    Named.prototype.on = function(event, callback) {
      if (!((event != null) && (callback != null))) {
        throw Error('on() event and callback required');
      }
      if (this.listener == null) {
        this.listener = {};
      }
      if (this.listener[event] == null) {
        this.listener[event] = [];
      }
      if (-1 === this.listener[event].indexOf(callback)) {
        this.listener[event].push(callback);
      }
      return this;
    };

    Named.prototype.off = function(event, callback) {
      var index;
      if ((event != null) && (callback != null)) {
        if (this.listener[event] != null) {
          index = this.listener[event].indexOf(callback);
          if (index !== -1) {
            this.listener[event].splice(index, 1);
          }
        }
      } else if (event != null) {
        delete this.listener[event];
      } else if (callback != null) {
        for (event in this.listener) {
          index = this.listener[event].indexOf(callback);
          if (index !== -1) {
            this.listener[event].splice(index, 1);
          }
        }
      } else {
        delete this.listener;
      }
      return this;
    };

    Named.prototype.trigger = function() {
      var args, callback, event, j, len, ref, ref1;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (((ref = this.listener) != null ? ref[event] : void 0) != null) {
        ref1 = this.listener[event];
        for (j = 0, len = ref1.length; j < len; j++) {
          callback = ref1[j];
          setTimeout((function() {
            return callback.apply(this, args);
          }), 0);
        }
      }
      return this;
    };

    return Named;

  })();

}).call(this);
// Generated by CoffeeScript 1.9.2
(function() {
  var slice = [].slice;

  cuttlebone.Scope = (function() {
    function Scope(scopeId, shell, balloon) {
      var clickable_element_style, descript, styles;
      this.scopeId = scopeId;
      this.shell = shell;
      this.balloon = balloon;
      this.$scope = $("<div />").addClass("scope");
      this.$surface = $("<div />").addClass("surface");
      this.$surfaceCanvas = $("<canvas width='10' height='100' />").addClass("surfaceCanvas");
      this.$blimp = $("<div />").addClass("blimp");
      this.$blimpCanvas = $("<canvas width='0' height='0' />").addClass("blimpCanvas");
      this.$blimpText = $("<div />").addClass("blimpText");
      descript = this.balloon.descript;
      styles = {};
      styles["cursor"] = descript["cursor"] || '';
      styles["font.name"] = (descript["font.name"] || "MS Gothic").split(/,/).map(function(name) {
        return '"' + name + '"';
      }).join(',');
      styles["font.height"] = (descript["font.height"] || "12") + "px";
      styles["font.color"] = this._getFontColor(descript["font.color.r"], descript["font.color.g"], descript["font.color.b"]);
      styles["font.shadowcolor"] = this._getFontColor(descript["font.shadowcolor.r"], descript["font.shadowcolor.g"], descript["font.shadowcolor.b"], true);
      styles["font.bold"] = descript["font.bold"];
      styles["font.italic"] = descript["font.italic"];
      styles["font.strike"] = descript["font.strike"];
      styles["font.underline"] = descript["font.underline"];
      this._text_style = styles;
      clickable_element_style = (function(_this) {
        return function(prefix, style_default, descript, can_ignore) {
          styles = {};
          styles["style"] = {
            square: true,
            underline: true,
            'square+underline': true,
            none: true
          }[descript[prefix + ".style"]] ? descript[prefix + ".style"] : style_default;
          styles["font.color"] = _this._getFontColor(descript[prefix + ".font.color.r"], descript[prefix + ".font.color.g"], descript[prefix + ".font.color.b"], can_ignore);
          styles["pen.color"] = _this._getFontColor(descript[prefix + ".pen.color.r"], descript[prefix + ".pen.color.g"], descript[prefix + ".pen.color.b"], can_ignore);
          styles["brush.color"] = _this._getFontColor(descript[prefix + ".brush.color.r"], descript[prefix + ".brush.color.g"], descript[prefix + ".brush.color.b"], can_ignore);
          return styles;
        };
      })(this);
      this._choice_style = clickable_element_style("cursor", "square", descript);
      this._choice_notselect_style = clickable_element_style("cursor.notselect", void 0, descript, true);
      this._anchor_style = clickable_element_style("anchor", "underline", descript);
      this._anchor_notselect_style = clickable_element_style("anchor.notselect", void 0, descript, true);
      this.$blimpText.css(this._blimpTextCSS(this._text_style));
      this._initializeCurrentStyle();
      this.isPointerEventsShimed = false;
      this.lastEventType = "";
      this.$surfaceCanvas.on("contextmenu", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseclick", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      this.$surfaceCanvas.on("click", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseclick", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      this.$surfaceCanvas.on("dblclick", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousedblclick", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      this.$surfaceCanvas.on("mousedown", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousedown", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      this.$surfaceCanvas.on("mousemove", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousemove", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      this.$surfaceCanvas.on("mouseup", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseup", function($ev) {
            return _this.$surfaceCanvas.trigger($ev);
          });
        };
      })(this));
      (function(_this) {
        return (function() {
          var tid, touchCount, touchStartTime;
          tid = 0;
          touchCount = 0;
          touchStartTime = 0;
          _this.$surfaceCanvas.on("touchmove", function(ev) {
            return _this.processMouseEvent(ev, "mousemove", function($ev) {
              return _this.$surfaceCanvas.trigger($ev);
            });
          });
          _this.$surfaceCanvas.on("touchend", function(ev) {
            _this.processMouseEvent(ev, "mouseup", function($ev) {
              return _this.$surfaceCanvas.trigger($ev);
            });
            _this.processMouseEvent(ev, "mouseclick", function($ev) {
              return _this.$surfaceCanvas.trigger($ev);
            });
            if (Date.now() - touchStartTime < 500 && touchCount % 2 === 0) {
              return _this.processMouseEvent(ev, "mousedblclick", function($ev) {
                return _this.$surfaceCanvas.trigger($ev);
              });
            }
          });
          return _this.$surfaceCanvas.on("touchstart", function(ev) {
            touchCount++;
            touchStartTime = Date.now();
            _this.processMouseEvent(ev, "mousedown", function($ev) {
              return _this.$surfaceCanvas.trigger($ev);
            });
            clearTimeout(tid);
            return tid = setTimeout((function() {
              return touchCount = 0;
            }), 500);
          });
        });
      })(this)();
      this.element = this.$scope[0];
      this.destructors = [];
      this.currentSurface = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, 0);
      this.currentBalloon = this.balloon.attachSurface(this.$blimpCanvas[0], this.scopeId, 0);
      this.isBalloonLeft = true;
      this.insertPoint = this.$blimpText;
      this.$blimp.append(this.$blimpCanvas);
      this.$blimp.append(this.$blimpText);
      this.$surface.append(this.$surfaceCanvas);
      this.$scope.append(this.$surface);
      this.$scope.append(this.$blimp);
      this.$scope.css({
        "bottom": "0px",
        "right": (this.scopeId * 240) + "px"
      });
      this.surface(0);
      this.blimp(0);
      this.surface(-1);
      this.blimp(-1);
    }

    Scope.prototype.surface = function(surfaceId){
    if(typeof surfaceId === "undefined"){
      return this.currentSurface;
    }
    if(Number(surfaceId) < 0){
      this.$surface.hide();
      return this.currentSurface;
    }
    if(!this.shell.hasSurface(this.scopeId, surfaceId)){
      console.warn("Scope#surface > ReferenceError: surfaceId", surfaceId, "is not defined")
      return this.currentSurface;
    }
    this.shell.detachSurface(this.$surfaceCanvas[0]);
    this.currentSurface = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, surfaceId);
    this.$scope.width(this.$surfaceCanvas[0].width);
    this.$scope.height(this.$surfaceCanvas[0].height);
    this.$surface.show();
    return this.currentSurface;
  };

    Scope.prototype.processMouseEvent = function(ev, eventName, callback) {
      var _ev, detail, elm, hit, left, offsetX, offsetY, pageX, pageY, ref, ref1, top, touches;
      $(ev.target).css({
        "cursor": "default"
      });
      if (this.isPointerEventsShimed && ev.type === this.lastEventType) {
        this.lastEventType = "";
        this.isPointerEventsShimed = false;
        ev.stopPropagation();
        ev.preventDefault();
        return;
      }
      if (/^touch/.test(ev.type)) {
        ref = ev.changedTouches[0], pageX = ref.pageX, pageY = ref.pageY;
      } else {
        pageX = ev.pageX, pageY = ev.pageY;
      }
      ref1 = $(ev.target).offset(), left = ref1.left, top = ref1.top;
      offsetX = pageX - left;
      offsetY = pageY - top;
      hit = this.currentSurface.getRegion(offsetX, offsetY);
      if (hit.isHit) {
        ev.preventDefault();
        detail = {
          "type": eventName,
          "offsetX": offsetX | 0,
          "offsetY": offsetY | 0,
          "wheel": 0,
          "scope": this.scopeId,
          "region": hit.name,
          "button": (ev.button === 2 ? 1 : 0)
        };
        if (hit.name.length > 0) {
          if (/^touch/.test(ev.type)) {
            ev.stopPropagation();
          }
          $(ev.target).css({
            "cursor": "pointer"
          });
        }
        callback($.Event('IkagakaDOMEvent', {
          detail: detail,
          bubbles: true
        }));
      } else {
        elm = cuttlebone.SurfaceUtil.elementFromPointWithout(ev.target, ev.pageX, ev.pageY);
        if (!elm) {
          return;
        }
        if (/^mouse/.test(ev.type)) {
          this.isPointerEventsShimed = true;
          this.lastEventType = ev.type;
          ev.preventDefault();
          ev.stopPropagation();
          _ev = document.createEvent("MouseEvent");
          if (typeof _ev.initMouseEvent === "function") {
            _ev.initMouseEvent(ev.type, ev.bubbles, ev.cancelable, ev.view, ev.detail, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, ev.button, ev.relatedTarget);
          }
          elm.dispatchEvent(_ev);
        } else if (/^touch/.test(ev.type) && !!document.createTouchList) {
          this.isPointerEventsShimed = true;
          this.lastEventType = ev.type;
          ev.preventDefault();
          ev.stopPropagation();
          touches = document.createTouchList();
          touches[0] = document.createTouch(document.body, ev.target, 0, ev.pageX, ev.pageY, ev.screenX, ev.screenY, ev.clientX, ev.clientY, 1, 1, 0, 1.0);
          _ev = document.createEvent("TouchEvent");
          _ev.initTouchEvent(touches, touches, touches, ev.type, ev.view, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey);
          elm.dispatchEvent(_ev);
        }
      }
    };

    Scope.prototype.blimp = function(balloonId) {
      var b, descript, h, l, location, r, t, tmp, type, w;
      if (Number(balloonId) < 0) {
        this.$blimp.hide();
      } else {
        if (balloonId != null) {
          this.currentBalloon.destructor();
          tmp = this.balloon.attachSurface(this.$blimpCanvas[0], this.scopeId, balloonId);
          this.currentBalloon = tmp;
          this.$blimp.width(this.$blimpCanvas[0].width);
          this.$blimp.height(this.$blimpCanvas[0].height);
          this.$blimp.show();
          descript = this.currentBalloon.descript;
          type = this.scopeId === 0 ? "sakura" : "kero";
          this.$blimp.css({
            "top": Number(this.shell.descript[type + ".balloon.offsety"] || 0)
          });
          if (this.isBalloonLeft) {
            this.$blimp.css({
              "left": Number(this.shell.descript[type + ".balloon.offsetx"] || 0) + -1 * this.$blimpCanvas[0].width
            });
          } else {
            this.$blimp.css({
              "left": Number(this.shell.descript[type + ".balloon.offsetx"] || 0) + this.$surfaceCanvas[0].width
            });
          }
          t = descript["origin.y"] || descript["validrect.top"] || "10";
          r = descript["validrect.right"] || "10";
          b = descript["validrect.bottom"] || "10";
          l = descript["origin.x"] || descript["validrect.left"] || "10";
          w = this.$blimpCanvas[0].width;
          h = this.$blimpCanvas[0].height;
          this.$blimpText.css({
            "top": t + "px",
            "left": l + "px",
            "width": (w - (Number(l) + Number(r))) + "px",
            "height": (h - (Number(t) - Number(b))) + "px"
          });
        }
      }
      location = (function(_this) {
        return function(x, y) {
          var $imp_position_checker, $newimp, $newimp_container, $newimp_container_top, baseoffset, offset, offsetx, offsety, re, toparam, xp, yp;
          re = /^(@)?(-?\d*\.?\d*e?\d*)(em|%)?$/;
          toparam = function(r) {
            var rp, unit, value;
            if (!((r != null) && r.length)) {
              return {
                relative: true,
                value: 0
              };
            }
            rp = r.match(re);
            if (!rp) {
              return;
            }
            if (isNaN(rp[2])) {
              return;
            }
            if (rp[3] === '%') {
              value = rp[2] / 100;
              unit = 'em';
            } else {
              value = Number(rp[2]);
              unit = rp[3] || 'px';
            }
            return {
              relative: !!rp[1],
              value: value + unit
            };
          };
          xp = toparam(x);
          yp = toparam(y);
          if (!((xp != null) && (yp != null))) {
            return;
          }
          if (xp.relative || yp.relative) {
            $imp_position_checker = $('<span>.</span>');
            _this.insertPoint.append($imp_position_checker);
            offset = $imp_position_checker.offset();
            baseoffset = _this.$blimpText.offset();
            offsetx = offset.left - baseoffset.left;
            offsety = offset.top - baseoffset.top + _this.$blimpText.scrollTop();
            $imp_position_checker.remove();
          }
          if (!xp.relative) {
            offsetx = 0;
          }
          if (!yp.relative) {
            offsety = 0;
          }
          $newimp_container_top = $('<div />').css({
            'position': 'absolute',
            'pointer-events': 'none',
            'top': yp.value
          });
          $newimp_container = $('<div />').css({
            'position': 'absolute',
            'pointer-events': 'none',
            'text-indent': offsetx + 'px',
            'top': offsety + 'px',
            'width': _this.$blimpText[0].clientWidth
          });
          $newimp = $('<span />').css({
            'pointer-events': 'auto',
            'margin-left': xp.value
          });
          _this.insertPoint = $newimp.appendTo($newimp_container.appendTo($newimp_container_top.appendTo(_this.$blimpText)));
          return _this.insertPoint.css(_this._blimpTextCSS(_this._current_text_style));
        };
      })(this);
      return {
        anchorBegin: (function(_this) {
          return function() {
            var $a, _id, anchor_css, anchor_notselect_css, args, argv, i, id, index, len, text_css;
            id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-anchor");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            anchor_css = _this._blimpClickableTextCSS(_this._current_anchor_style);
            anchor_notselect_css = _this._blimpClickableTextCSS(_this._current_anchor_notselect_style, _this._current_anchor_style);
            $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(anchor_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
            });
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = i = 0, len = args.length; i < len; index = ++i) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            _this.originalInsertPoint = _this.insertPoint;
            _this.insertPoint = $a.appendTo(_this.insertPoint);
          };
        })(this),
        anchorEnd: (function(_this) {
          return function() {
            _this.insertPoint = _this.originalInsertPoint;
          };
        })(this),
        choice: (function(_this) {
          return function() {
            var $a, _id, _text, args, argv, choice_css, choice_notselect_css, i, id, index, len, text, text_css;
            text = arguments[0], id = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _text = $(document.createElement("div")).text(text).html();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-choice");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            choice_css = _this._blimpClickableTextCSS(_this._current_choice_style);
            choice_notselect_css = _this._blimpClickableTextCSS(_this._current_choice_notselect_style, _this._current_text_style);
            $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(choice_css.base).css(choice_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            });
            $a.html(_text);
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = i = 0, len = args.length; i < len; index = ++i) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            $a.appendTo(_this.insertPoint);
          };
        })(this),
        choiceBegin: (function(_this) {
          return function() {
            var $a, _id, args, argv, choice_css, choice_notselect_css, i, id, index, len, text_css;
            id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-choice");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            choice_css = _this._blimpClickableTextCSS(_this._current_choice_style);
            choice_notselect_css = _this._blimpClickableTextCSS(_this._current_choice_notselect_style, _this._current_text_style);
            $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(choice_css.base).css(choice_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            });
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = i = 0, len = args.length; i < len; index = ++i) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            _this.originalInsertPoint = _this.insertPoint;
            _this.insertPoint = $a.appendTo(_this.insertPoint);
          };
        })(this),
        choiceEnd: (function(_this) {
          return function() {
            _this.insertPoint = _this.originalInsertPoint;
          };
        })(this),
        talk: (function(_this) {
          return function(text) {
            var _text;
            _this.$blimpText.find(".blink").hide();
            _text = $(document.createElement("div")).text(text).html();
            if (!!_this.currentSurface) {
              _this.currentSurface.talk();
            }
            _this.$blimp.show();
            _this.insertPoint.append(_text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        talkraw: (function(_this) {
          return function(text) {
            _this.$blimpText.find(".blink").hide();
            if (!!_this.currentSurface) {
              _this.currentSurface.talk();
            }
            _this.$blimp.show();
            _this.insertPoint.append(text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        marker: (function(_this) {
          return function() {
            var _text;
            _this.$blimpText.find(".blink").hide();
            _text = $(document.createElement("div")).text("・").html();
            _this.$blimp.show();
            _this.insertPoint.append(_text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        clear: (function(_this) {
          return function() {
            _this.$blimpText.html("");
            _this.insertPoint = _this.$blimpText;
            _this._initializeCurrentStyle();
          };
        })(this),
        br: (function(_this) {
          return function(ratio) {
            if (ratio != null) {
              location('0', '@' + ratio + 'em');
            } else {
              _this.insertPoint.append("<br />");
            }
          };
        })(this),
        showWait: (function(_this) {
          return function() {
            _this.$blimpText.append("<br /><br />").append("<div class='blink'>▼</div>");
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        font: (function(_this) {
          return function() {
            var $newimp, $size_checker, is_text_style, name, size, treat_bool, treat_clickable_styles, value, values;
            name = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            value = values[0];
            treat_bool = function(name, value) {
              if (value === 'default') {
                return _this._current_text_style["font." + name] = _this._text_style["font." + name];
              } else {
                return _this._current_text_style["font." + name] = !((value === 'false') || ((value - 0) === 0));
              }
            };
            treat_clickable_styles = function(treat_name, name, value, values, _current_style, _style) {
              switch (name) {
                case treat_name + "style":
                  if (value === 'default') {
                    return _current_style["style"] = _style["style"];
                  } else {
                    return _current_style["style"] = value;
                  }
                  break;
                case treat_name + "fontcolor":
                  if (value === 'default') {
                    return _current_style["font.color"] = _style["font.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["font.color"] = value;
                  }
                  break;
                case treat_name + "pencolor":
                  if (value === 'default') {
                    return _current_style["pen.color"] = _style["pen.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["pen.color"] = _this._getpenColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["pen.color"] = value;
                  }
                  break;
                case treat_name + "color":
                case treat_name + "brushcolor":
                  if (value === 'default') {
                    return _current_style["brush.color"] = _style["brush.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["brush.color"] = _this._getFontColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["brush.color"] = value;
                  }
              }
            };
            switch (name) {
              case 'name':
                is_text_style = true;
                _this._current_text_style["font.name"] = values.map(function(name) {
                  return '"' + name + '"';
                }).join(',');
                break;
              case 'height':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.height"] = _this._text_style["font.height"];
                } else if (/^[+-]/.test(value)) {
                  $size_checker = $('<span />').text('I').css({
                    position: 'absolute',
                    visibility: 'hidden',
                    'width': '1em',
                    'font-size': '1em',
                    padding: 0,
                    'line-height': '1em'
                  });
                  _this.insertPoint.append($size_checker);
                  size = $size_checker[0].clientHeight;
                  $size_checker.remove();
                  _this._current_text_style["font.height"] = (Number(size) + Number(value)) + 'px';
                } else if (!isNaN(value)) {
                  _this._current_text_style["font.height"] = value + 'px';
                } else {
                  _this._current_text_style["font.height"] = value;
                }
                break;
              case 'color':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.color"] = _this._text_style["font.color"];
                } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                  _this._current_text_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
                } else {
                  _this._current_text_style["font.color"] = value;
                }
                break;
              case 'shadowcolor':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.shadowcolor"] = _this._text_style["font.shadowcolor"];
                } else if (value === 'none') {
                  _this._current_text_style["font.shadowcolor"] = void 0;
                } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                  _this._current_text_style["font.shadowcolor"] = _this._getFontColor(values[0], values[1], values[2]);
                } else {
                  _this._current_text_style["font.shadowcolor"] = value;
                }
                break;
              case 'bold':
                is_text_style = true;
                treat_bool('bold', value);
                break;
              case 'italic':
                is_text_style = true;
                treat_bool('italic', value);
                break;
              case 'strike':
                is_text_style = true;
                treat_bool('strike', value);
                break;
              case 'underline':
                is_text_style = true;
                treat_bool('underline', value);
                break;
              case 'default':
                is_text_style = true;
                _this._initializeCurrentStyle();
                break;
              case 'cursorstyle':
              case 'cursorfontcolor':
              case 'cursorpencolor':
              case 'cursorcolor':
              case 'cursorbrushcolor':
                treat_clickable_styles('cursor', name, value, values, _this._current_choice_style, _this._choice_style);
                break;
              case 'anchorstyle':
              case 'anchorfontcolor':
              case 'anchorpencolor':
              case 'anchorcolor':
              case 'anchorbrushcolor':
                treat_clickable_styles('anchor', name, value, values, _this._current_anchor_style, _this._anchor_style);
                break;
              case 'cursornotselectstyle':
              case 'cursornotselectfontcolor':
              case 'cursornotselectpencolor':
              case 'cursornotselectcolor':
              case 'cursornotselectbrushcolor':
                treat_clickable_styles('cursornotselect', name, value, values, _this._current_choice_notselect_style, _this._choice_notselect_style);
                break;
              case 'anchornotselectstyle':
              case 'anchornotselectfontcolor':
              case 'anchornotselectpencolor':
              case 'anchornotselectcolor':
              case 'anchornotselectbrushcolor':
                treat_clickable_styles('anchornotselect', name, value, values, _this._current_anchor_notselect_style, _this._anchor_notselect_style);
            }
            if (is_text_style) {
              $newimp = $('<span />');
              _this.insertPoint = $newimp.appendTo(_this.insertPoint);
              return _this.insertPoint.css(_this._blimpTextCSS(_this._current_text_style));
            }
          };
        })(this),
        location: location
      };
    };

    Scope.prototype._blimpTextCSS = function(styles) {
      var css, text_decoration;
      css = {};
      css["cursor"] = styles["cursor"];
      css["font-family"] = styles["font.name"];
      css["font-size"] = styles["font.height"];
      css["color"] = styles["font.color"];
      css["background"] = "none";
      css["outline"] = "none";
      css["border"] = "none";
      css["text-shadow"] = styles["font.shadowcolor"] ? "1px 1px 0 " + styles["font.shadowcolor"] : "none";
      css["font-weight"] = styles["font.bold"] ? "bold" : "normal";
      css["font-style"] = styles["font.italic"] ? "italic" : "normal";
      text_decoration = [];
      if (styles["font.strike"]) {
        text_decoration.push('line-through');
      }
      if (styles["font.underline"]) {
        text_decoration.push('underline');
      }
      css["text-decoration"] = text_decoration.length ? text_decoration.join(' ') : "none";
      css["line-height"] = "1.2em";
      return css;
    };

    Scope.prototype._blimpClickableTextCSS = function(styles, default_styles) {
      var background, border_bottom, color, outline;
      if (default_styles == null) {
        default_styles = {};
      }
      color = styles["font.color"] || default_styles["font.color"];
      outline = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      background = styles["brush.color"] || default_styles["brush.color"] || default_styles["font.color"];
      border_bottom = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      switch (styles["style"]) {
        case "square":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              "border-bottom": "none"
            }
          };
        case "underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              'border-bottom': border_bottom
            }
          };
        case "square+underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              'border-bottom': border_bottom
            }
          };
        case "none":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              "border-bottom": "none"
            }
          };
        default:
          return {
            base: {},
            over: {}
          };
      }
    };

    Scope.prototype._initializeCurrentStyle = function() {
      var name, ref, ref1, ref2, ref3, ref4, results, value;
      this._current_text_style = {};
      ref = this._text_style;
      for (name in ref) {
        value = ref[name];
        this._current_text_style[name] = value;
      }
      this._current_choice_style = {};
      ref1 = this._choice_style;
      for (name in ref1) {
        value = ref1[name];
        this._current_choice_style[name] = value;
      }
      this._current_choice_notselect_style = {};
      ref2 = this._choice_notselect_style;
      for (name in ref2) {
        value = ref2[name];
        this._current_choice_notselect_style[name] = value;
      }
      this._current_anchor_style = {};
      ref3 = this._anchor_style;
      for (name in ref3) {
        value = ref3[name];
        this._current_anchor_style[name] = value;
      }
      this._current_anchor_notselect_style = {};
      ref4 = this._anchor_notselect_style;
      results = [];
      for (name in ref4) {
        value = ref4[name];
        results.push(this._current_anchor_notselect_style[name] = value);
      }
      return results;
    };

    Scope.prototype._getFontColor = function(r, g, b, can_ignore) {
      var bc, gc, rc;
      rc = r != null ? r.replace(/%$/, '') : void 0;
      gc = g != null ? g.replace(/%$/, '') : void 0;
      bc = b != null ? b.replace(/%$/, '') : void 0;
      if ((isNaN(rc) || rc < 0) && (isNaN(gc) || gc < 0) && (isNaN(bc) || bc < 0)) {
        if (can_ignore) {

        } else {
          return "rgb(0,0,0)";
        }
      } else {
        return "rgb(" + r + "," + g + "," + b + ")";
      }
    };

    return Scope;

  })();

}).call(this);
// Generated by CoffeeScript 1.9.2
(function() {
  cuttlebone.Balloon = (function() {
    function Balloon(directory) {
      this.directory = directory;
      this.descript = null;
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      var prm;
      if (!!this.directory["descript.txt"]) {
        this.descript = cuttlebone.Util.parseDescript(cuttlebone.Util.convert(this.directory["descript.txt"]));
      } else {
        this.descript = {};
        console.warn("descript.txt is not found");
      }
      prm = Promise.resolve(this.balloons);
      prm = prm.then(Balloon.loadBalloonSurfaces(this.directory));
      prm = prm.then(Balloon.loadBalloonDescripts(this.directory, this.descript));
      prm = prm.then((function(_this) {
        return function(balloons) {
          _this.balloons = balloons;
          _this.directory = null;
          return _this;
        };
      })(this));
      prm = prm["catch"](function(err) {
        console.error(err);
        err.message && console.error(err.message);
        err.stack && console.error(err.stack);
        throw err;
      });
      return prm;
    };

    Balloon.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][surfaceId] == null) {
        return null;
      }
      return new cuttlebone.BalloonSurface(canvas, scopeId, this.balloons[type][surfaceId], this.balloons);
    };

    Balloon.loadBalloonDescripts = function(directory, descript) {
      return function(balloons) {
        return new Promise(function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref, type;
            buffer = directory[filepath];
            _descript = cuttlebone.Util.parseDescript(cuttlebone.Util.convert(buffer));
            ref = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = $.extend(true, _descript, descript);
              case "k":
                return balloons["kero"][Number(n)].descript = $.extend(true, _descript, descript);
            }
          });
          return resolve(balloons);
        });
      };
    };

    Balloon.loadBalloonSurfaces = function(directory) {
      return function(balloons) {
        var hits, keys, promises;
        keys = Object.keys(directory);
        hits = keys.filter(function(filepath) {
          return /[^\/]+\.png$/.test(filepath);
        });
        promises = hits.map(function(filepath) {
          return new Promise(function(resolve, reject) {
            var buffer, url;
            buffer = directory[filepath];
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return cuttlebone.SurfaceUtil.fetchImageFromURL(url).then(function(img) {
              return [null, img];
            })["catch"](function(err) {
              return [err, null];
            }).then(function(arg) {
              var __, err, img, n, ref, ref1, ref2, rndr, type;
              err = arg[0], img = arg[1];
              if (!!err) {
                return reject(err);
              }
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err);
              }
              rndr = new cuttlebone.SurfaceRender(cuttlebone.SurfaceUtil.copy(img));
              rndr.chromakey();
              if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
                ref = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
                switch (type) {
                  case "s":
                    balloons["sakura"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                    break;
                  case "k":
                    balloons["kero"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                    break;
                  case "c":
                    balloons["communicate"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                }
              } else if (/^online(\d+)\.png$/.test(filepath)) {
                ref1 = /^online(\d+)\.png$/.exec(filepath), __ = ref1[0], n = ref1[1];
                balloons["online"][Number(n)] = {
                  canvas: rndr.cnv
                };
              } else if (/^arrow(\d+)\.png$/.test(filepath)) {
                ref2 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
                balloons["arrow"][Number(n)] = {
                  canvas: rndr.cnv
                };
              } else if (/^sstp\.png$/.test(filepath)) {
                balloons["sstp"] = {
                  canvas: rndr.cnv
                };
              } else if (/^thumbnail\.png$/.test(filepath)) {
                balloons["thumbnail"] = {
                  canvas: rndr.cnv
                };
              }
              return resolve();
            });
          });
        });
        return new Promise(function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(balloons);
          });
        });
      };
    };

    return Balloon;

  })();

}).call(this);
// Generated by CoffeeScript 1.9.2
(function() {
  cuttlebone.BalloonSurface = (function() {
    function BalloonSurface(element, scopeId, balloonConf, balloons) {
      this.element = element;
      this.scopeId = scopeId;
      this.balloons = balloons;
      this.descript = balloonConf.descript;
      this.baseCanvas = balloonConf.canvas;
      this.render();
    }

    BalloonSurface.prototype.destructor = function() {};

    BalloonSurface.prototype.render = function() {
      var type, util;
      type = this.scopeId === 0 ? "sakura" : "kero";
      util = new cuttlebone.SurfaceRender(this.element);
      util.init(this.baseCanvas);
    };

    return BalloonSurface;

  })();

}).call(this);
/// <reference path="./Surface"/>
/// <reference path="./SurfaceUtil"/>
/// <reference path="./SurfaceRender"/>
/// <reference path="./BlobWorker"/>
/// <reference path="../tsd/SurfacesTxt2Yaml/SurfacesTxt2Yaml.d.ts"/>
/// <reference path="../tsd/encoding-japanese/encoding.d.ts"/>
/// <reference path="../typings/bluebird/bluebird.d.ts"/>
var cuttlebone;
(function (cuttlebone) {
    /**
     * extend deep like jQuery $.extend(true, target, source)
     */
    function extend(target, source) {
        for (var key in source) {
            if (typeof source[key] === "object" && Object.getPrototypeOf(source[key]) === Object.prototype) {
                target[key] = target[key] || {};
                extend(target[key], source[key]);
            }
            else if (Array.isArray(source[key])) {
                target[key] = target[key] || [];
                extend(target[key], source[key]);
            }
            else if (source[key] !== undefined) {
                target[key] = source[key];
            }
        }
    }
    /**
     * "hoge.huga, foo, bar\n" to {"hoge.huga": "foo, bar"}
     */
    function parseDescript(text) {
        text = text.replace(/(?:\r\n|\r|\n)/g, "\n"); // CRLF->LF
        while (true) {
            var match = (/(?:(?:^|\s)\/\/.*)|^\s+?$/g.exec(text) || ["", ""])[0];
            if (match.length === 0)
                break;
            text = text.replace(match, "");
        }
        var lines = text.split("\n");
        lines = lines.filter(function (line) { return line.length !== 0; }); // remove no content line
        var dic = lines.reduce(function (dic, line) {
            var tmp = line.split(",");
            var key = tmp[0];
            var vals = tmp.slice(1);
            key = key.trim();
            var val = vals.join(",").trim();
            dic[key] = val;
            return dic;
        }, {});
        return dic;
    }
    /**
     * convert some encoding txt file arraybuffer to js string
     */
    function convert(buffer) {
        return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
    }
    /**
     * find filename that matches arg "filename" from arg "paths"
     */
    function find(paths, filename) {
        filename = filename.split("\\").join("/");
        if (filename.slice(0, 2) === "./")
            filename = filename.slice(2);
        var reg = new RegExp("^" + filename.replace(".", "\.") + "$", "i");
        var hits = paths.filter(function (key) { return reg.test(key); });
        return hits;
    }
    var Shell = (function () {
        function Shell(directory) {
            this.directory = directory;
            this.descript = {};
            this.surfaces = [];
            this.surfacesTxt = {};
            this.surfaceTree = [];
            this.canvasCache = {};
            this.bindgroup = [];
            this.enableRegionVisible = false;
            this.enablePNGDecoder = false;
        }
        Shell.prototype.load = function () {
            var _this = this;
            return Promise.resolve(this)
                .then(function () { return _this.loadDescript(); }) // 1st
                .then(function () { return _this.loadBindGroup(); }) // 2nd
                .then(function () { return _this.loadSurfacesTxt(); }) // 1st
                .then(function () { return _this.loadSurfaceTable(); }) // 1st
                .then(function () { return _this.loadSurfacePNG(); }) // 2nd
                .then(function () { return _this.loadCollisions(); }) // 3rd
                .then(function () { return _this.loadAnimations(); }) // 3rd
                .then(function () { return _this.loadElements(); }) // 3rd
                .catch(function (err) {
                console.error("Shell#load > ", err);
                return Promise.reject(err);
            });
        };
        // load descript
        Shell.prototype.loadDescript = function () {
            var descript_name = Object.keys(this.directory).filter(function (name) { return /^descript\.txt$/i.test(name); })[0] || "";
            if (descript_name === "") {
                console.warn("descript.txt is not found");
            }
            else {
                this.descript = parseDescript(convert(this.directory[descript_name]));
            }
            return Promise.resolve(this);
        };
        Shell.prototype.loadBindGroup = function () {
            var _this = this;
            // load bindgroup
            var reg = /^(sakura|kero|char\d+)\.bindgroup(\d+)\.default/;
            Object.keys(this.descript).filter(function (key) { return reg.test(key); }).forEach(function (key) {
                var _a = reg.exec(key), _ = _a[0], charId = _a[1], bindgroupId = _a[2], type = _a[3];
                _this.bindgroup[Number(bindgroupId)] = _this.descript[key] === "1";
            });
            return Promise.resolve(this);
        };
        // load surfaces.txt
        Shell.prototype.loadSurfacesTxt = function () {
            var _this = this;
            var surfaces_text_names = Object.keys(this.directory).filter(function (name) { return /^surfaces.*\.txt$|^alias\.txt$/i.test(name); });
            if (surfaces_text_names.length === 0) {
                console.info("surfaces.txt is not found");
            }
            else {
                surfaces_text_names.forEach(function (filename) {
                    var srfs = SurfacesTxt2Yaml.txt_to_data(convert(_this.directory[filename]), { compatible: 'ssp-lazy' });
                    extend(_this.surfacesTxt, srfs);
                });
                //{ expand inherit and remove
                Object.keys(this.surfacesTxt.surfaces).forEach(function (name) {
                    if (typeof _this.surfacesTxt.surfaces[name].is === "number"
                        && Array.isArray(_this.surfacesTxt.surfaces[name].base)) {
                        _this.surfacesTxt.surfaces[name].base.forEach(function (key) {
                            extend(_this.surfacesTxt.surfaces[name], _this.surfacesTxt.surfaces[key]);
                        });
                        delete _this.surfacesTxt.surfaces[name].base;
                    }
                });
                Object.keys(this.surfacesTxt.surfaces).forEach(function (name) {
                    if (typeof _this.surfacesTxt.surfaces[name].is === "undefined") {
                        delete _this.surfacesTxt.surfaces[name];
                    }
                });
            }
            return Promise.resolve(this);
        };
        // load surfacetable.txt
        Shell.prototype.loadSurfaceTable = function () {
            var surfacetable_name = Object.keys(this.directory).filter(function (name) { return /^surfacetable.*\.txt$/i.test(name); })[0] || "";
            if (surfacetable_name === "") {
                console.info("surfacetable.txt is not found.");
            }
            else {
                var txt = convert(this.directory[surfacetable_name]);
            }
            return Promise.resolve(this);
        };
        // load surface*.png and surface*.pna
        Shell.prototype.loadSurfacePNG = function () {
            var _this = this;
            var surface_names = Object.keys(this.directory).filter(function (filename) { return /^surface(\d+)\.png$/i.test(filename); });
            var prms = surface_names.map(function (filename) {
                var n = Number(/^surface(\d+)\.png$/i.exec(filename)[1]);
                _this.getPNGFromDirectory(filename).then(function (cnv) {
                    if (!_this.surfaceTree[n]) {
                        _this.surfaceTree[n] = {
                            base: cnv,
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    }
                    else {
                        _this.surfaceTree[n].base = cnv;
                    }
                }).catch(function (err) {
                    console.warn("Shell#loadSurfacePNG > " + err);
                    return Promise.resolve();
                });
            });
            return Promise.all(prms).then(function () { return Promise.resolve(_this); });
        };
        // load elements
        Shell.prototype.loadElements = function () {
            var _this = this;
            var srfs = this.surfacesTxt.surfaces;
            var hits = Object.keys(srfs).filter(function (name) { return !!srfs[name].elements; });
            var prms = hits.map(function (defname) {
                var n = srfs[defname].is;
                var elms = srfs[defname].elements;
                var _prms = Object.keys(elms).map(function (elmname) {
                    var _a = elms[elmname], is = _a.is, type = _a.type, file = _a.file, x = _a.x, y = _a.y;
                    return _this.getPNGFromDirectory(file).then(function (canvas) {
                        if (!_this.surfaceTree[n]) {
                            _this.surfaceTree[n] = {
                                base: cuttlebone.SurfaceUtil.createCanvas(),
                                elements: [],
                                collisions: [],
                                animations: []
                            };
                        }
                        _this.surfaceTree[n].elements[is] = { type: type, canvas: canvas, x: x, y: y };
                        return Promise.resolve(_this);
                    }).catch(function (err) {
                        console.warn("Shell#loadElements > " + err);
                        return Promise.resolve(_this);
                    });
                });
                return Promise.all(_prms).then(function () {
                    return Promise.resolve(_this);
                });
            });
            return Promise.all(prms).then(function () {
                return Promise.resolve(_this);
            });
        };
        // load collisions
        Shell.prototype.loadCollisions = function () {
            var _this = this;
            var srfs = this.surfacesTxt.surfaces;
            Object.keys(srfs).filter(function (name) { return !!srfs[name].regions; }).forEach(function (defname) {
                var n = srfs[defname].is;
                var regions = srfs[defname].regions;
                Object.keys(regions).forEach(function (regname) {
                    if (!_this.surfaceTree[n]) {
                        _this.surfaceTree[n] = {
                            base: cuttlebone.SurfaceUtil.createCanvas(),
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    }
                    var is = regions[regname].is;
                    _this.surfaceTree[n].collisions[is] = regions[regname];
                });
            });
            return Promise.resolve(this);
        };
        // load animations
        Shell.prototype.loadAnimations = function () {
            var _this = this;
            var srfs = this.surfacesTxt.surfaces;
            Object.keys(srfs).filter(function (name) { return !!srfs[name].animations; }).forEach(function (defname) {
                var n = srfs[defname].is;
                var animations = srfs[defname].animations;
                Object.keys(animations).forEach(function (animname) {
                    if (!_this.surfaceTree[n]) {
                        _this.surfaceTree[n] = {
                            base: cuttlebone.SurfaceUtil.createCanvas(),
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    }
                    var _a = animations[animname], is = _a.is, interval = _a.interval;
                    _this.surfaceTree[n].animations[is] = animations[animname];
                });
            });
            return Promise.resolve(this);
        };
        Shell.prototype.hasFile = function (filename) {
            return find(Object.keys(this.directory), filename).length > 0;
        };
        Shell.prototype.getPNGFromDirectory = function (filename) {
            var _this = this;
            var cached_filename = find(Object.keys(this.canvasCache), filename)[0] || "";
            if (cached_filename !== "") {
                return Promise.resolve(this.canvasCache[cached_filename]);
            }
            if (!this.hasFile(filename)) {
                filename += ".png";
                if (!this.hasFile(filename)) {
                    return Promise.reject(new Error("no such file in directory: " + filename.replace(/\.png$/i, "")));
                }
                console.warn("element file " + filename + " need '.png' extension");
            }
            var _filename = find(Object.keys(this.directory), filename)[0];
            var pnafilename = _filename.replace(/\.png$/i, ".pna");
            var _pnafilename = find(Object.keys(this.directory), pnafilename)[0] || "";
            var pngbuf = this.directory[_filename];
            var pnabuf = this.directory[_pnafilename];
            var render = new cuttlebone.SurfaceRender(cuttlebone.SurfaceUtil.createCanvas());
            var planB = function () {
                // pngjs way
                return cuttlebone.SurfaceUtil.fetchPNGUint8ClampedArrayFromArrayBuffer(pngbuf, pnabuf).then(function (pngdata) {
                    render.initImageData(pngdata.width, pngdata.height, pngdata.data);
                    _this.canvasCache[_filename] = render.cnv;
                    return render.cnv;
                });
            };
            var planC = function () {
                // basic way
                return cuttlebone.SurfaceUtil.fetchImageFromArrayBuffer(pngbuf).then(function (img) {
                    render.init(img);
                    if (_pnafilename === "") {
                        render.chromakey();
                        _this.canvasCache[_filename] = render.cnv;
                        return render.cnv;
                    }
                    return cuttlebone.SurfaceUtil.fetchImageFromArrayBuffer(pnabuf).then(function (pnaimg) {
                        render.pna(cuttlebone.SurfaceUtil.copy(pnaimg));
                        _this.canvasCache[_filename] = render.cnv;
                        return render.cnv;
                    });
                });
            };
            if (false && this.enablePNGDecoder) {
                return planB().catch(function (err) {
                    console.warn("getPNGFromDirectory(" + filename + ", pngjs) > ", err);
                    return planC();
                }).catch(function (err) {
                    return Promise.reject("getPNGFromDirectory(" + filename + ") > " + err);
                });
            }
            else {
                return planC().catch(function (err) {
                    return Promise.reject("getPNGFromDirectory(" + filename + ") > " + err);
                });
            }
        };
        Shell.prototype.attachSurface = function (canvas, scopeId, surfaceId) {
            var type = cuttlebone.SurfaceUtil.scope(scopeId);
            if (typeof surfaceId === "string") {
                if (!!this.surfacesTxt.aliases && !!this.surfacesTxt.aliases[type] && !!this.surfacesTxt.aliases[type][surfaceId]) {
                    var _surfaceId = cuttlebone.SurfaceUtil.choice(this.surfacesTxt.aliases[type][surfaceId]);
                }
                else
                    throw new Error("ReferenceError: surface alias scope:" + type + ", id:" + surfaceId + " is not defined.");
            }
            else if (typeof surfaceId === "number") {
                var _surfaceId = surfaceId;
            }
            else
                throw new Error("TypeError: surfaceId: number|string is not match " + typeof surfaceId);
            var tuple = this.surfaces.filter(function (tuple) { return tuple[0] === canvas; })[0];
            if (!!tuple)
                throw new Error("ReferenceError: this HTMLCanvasElement is already attached");
            var srf = new cuttlebone.Surface(canvas, scopeId, _surfaceId, this);
            this.surfaces.push([canvas, srf]);
            return srf;
        };
        Shell.prototype.detachSurface = function (canvas) {
            var tuple = this.surfaces.filter(function (tuple) { return tuple[0] === canvas; })[0];
            if (!tuple)
                return;
            tuple[1].destructor();
            this.surfaces.splice(this.surfaces.indexOf(tuple), 1);
        };
        Shell.prototype.hasSurface = function (scopeId, surfaceId) {
            var type = cuttlebone.SurfaceUtil.scope(scopeId);
            if (typeof surfaceId === "string") {
                if (!!this.surfacesTxt.aliases && !!this.surfacesTxt.aliases[type] && !!this.surfacesTxt.aliases[type][surfaceId]) {
                    var _surfaceId = cuttlebone.SurfaceUtil.choice(this.surfacesTxt.aliases[type][surfaceId]);
                }
                else {
                    throw new Error("RuntimeError: surface alias scope:" + type + ", id:" + surfaceId + " is not defined.");
                }
            }
            else if (typeof surfaceId === "number") {
                var _surfaceId = surfaceId;
            }
            else
                throw new Error("TypeError: surfaceId: number|string is not match " + typeof surfaceId);
            return this.surfaceTree[_surfaceId] != null;
        };
        Shell.prototype.bind = function (animationId) {
            this.bindgroup[animationId] = true;
            this.surfaces.forEach(function (tuple) {
                var _ = tuple[0], srf = tuple[1];
                srf.updateBind();
            });
        };
        Shell.prototype.unbind = function (animationId) {
            this.bindgroup[animationId] = false;
            this.surfaces.forEach(function (tuple) {
                var _ = tuple[0], srf = tuple[1];
                srf.updateBind();
            });
        };
        Shell.prototype.render = function () {
            this.surfaces.forEach(function (tuple) {
                var _ = tuple[0], srf = tuple[1];
                srf.render();
            });
        };
        return Shell;
    })();
    cuttlebone.Shell = Shell;
})(cuttlebone || (cuttlebone = {}));
/// <reference path="SurfaceRender.ts"/>
/// <reference path="SurfaceUtil.ts"/>
/// <reference path="Shell.ts"/>
/// <reference path="../typings/bluebird/bluebird.d.ts"/>
var cuttlebone;
(function (cuttlebone) {
    function randomRange(min, max) {
        return min + Math.floor(Math.random() * (max - min + 1));
    }
    var Surface = (function () {
        function Surface(canvas, scopeId, surfaceId, shell) {
            this.element = canvas;
            this.scopeId = scopeId;
            this.surfaceId = surfaceId;
            this.shell = shell;
            this.surfaceTreeNode = shell.surfaceTree[surfaceId];
            this.bufferCanvas = cuttlebone.SurfaceUtil.createCanvas();
            this.bufRender = new cuttlebone.SurfaceRender(this.bufferCanvas);
            this.elmRender = new cuttlebone.SurfaceRender(this.element);
            this.destructed = false;
            this.layers = {};
            this.stopFlags = {};
            this.talkCount = 0;
            this.talkCounts = {};
            this.initAnimations();
            this.render();
        }
        Surface.prototype.initAnimations = function () {
            var _this = this;
            this.surfaceTreeNode.animations.forEach(function (anim) {
                _this.initAnimation(anim);
            });
        };
        Surface.prototype.initAnimation = function (anim) {
            var _this = this;
            var is = anim.is, interval = anim.interval, patterns = anim.patterns;
            var tmp = interval.split(",");
            var _interval = tmp[0];
            if (tmp.length > 1) {
                var n = Number(tmp[1]);
                if (!isFinite(n)) {
                    console.warn("initAnimation > TypeError: surface", this.surfaceId, "animation", anim.is, "interval", interval, " argument is not finite number");
                    n = 4;
                }
            }
            switch (_interval) {
                case "sometimes":
                    cuttlebone.SurfaceUtil.random((function (callback) { if (!_this.destructed && !_this.stopFlags[is]) {
                        _this.play(is, callback);
                    } }), 2);
                    break;
                case "rarely":
                    cuttlebone.SurfaceUtil.random((function (callback) { if (!_this.destructed && !_this.stopFlags[is]) {
                        _this.play(is, callback);
                    } }), 4);
                    break;
                case "random":
                    cuttlebone.SurfaceUtil.random((function (callback) { if (!_this.destructed && !_this.stopFlags[is]) {
                        _this.play(is, callback);
                    } }), n);
                    break;
                case "periodic":
                    cuttlebone.SurfaceUtil.periodic((function (callback) { if (!_this.destructed && !_this.stopFlags[is]) {
                        _this.play(is, callback);
                    } }), n);
                    break;
                case "always":
                    cuttlebone.SurfaceUtil.always((function (callback) { if (!_this.destructed && !_this.stopFlags[is]) {
                        _this.play(is, callback);
                    } }));
                    break;
                case "runonce":
                    this.play(is);
                    break;
                case "never": break;
                case "yen-e": break;
                case "talk":
                    this.talkCounts[is] = n;
                    break;
                default:
                    if (/^bind/.test(interval)) {
                        this.initBind(anim);
                        break;
                    }
                    console.warn("Surface#initAnimation > unkown SERIKO or MAYURA interval:", interval, anim);
            }
        };
        Surface.prototype.updateBind = function () {
            var _this = this;
            this.surfaceTreeNode.animations.forEach(function (anim) {
                var is = anim.is, interval = anim.interval, patterns = anim.patterns;
                if (/^bind/.test(interval)) {
                    _this.initBind(anim);
                }
            });
        };
        Surface.prototype.initBind = function (anim) {
            var _this = this;
            var is = anim.is, interval = anim.interval, patterns = anim.patterns, option = anim.option;
            if (!this.shell.bindgroup[is]) {
                delete this.layers[is];
                this.stop(is);
                return;
            }
            var _a = interval.split("+"), _bind = _a[0], intervals = _a.slice(1);
            intervals.forEach(function (itvl) {
                _this.initAnimation({ interval: itvl, is: is, patterns: patterns, option: option });
            });
            if (intervals.length > 0)
                return;
            this.layers[is] = patterns[patterns.length - 1];
            this.render();
        };
        Surface.prototype.destructor = function () {
            this.elmRender.clear();
            this.destructed = true;
            this.layers = {};
        };
        Surface.prototype.render = function () {
            var _this = this;
            var renderLayers = Object.keys(this.layers)
                .sort(function (layerNumA, layerNumB) { return Number(layerNumA) > Number(layerNumB) ? 1 : -1; })
                .map(function (key) { return _this.layers[Number(key)]; })
                .reduce((function (arr, pattern) {
                var surface = pattern.surface, type = pattern.type, x = pattern.x, y = pattern.y;
                if (surface === -1)
                    return arr;
                var srf = _this.shell.surfaceTree[surface];
                if (srf == null)
                    return arr;
                var rndr = new cuttlebone.SurfaceRender(cuttlebone.SurfaceUtil.copy(srf.base));
                rndr.composeElements(srf.elements);
                //
                //
                return arr.concat({
                    type: type,
                    x: x,
                    y: y,
                    canvas: rndr.cnv
                });
            }), []);
            var srfNode = this.surfaceTreeNode;
            this.bufRender.init(srfNode.base);
            this.bufRender.composeElements(srfNode.elements);
            this.bufRender.composeElements(renderLayers);
            if (this.shell.enableRegionVisible) {
                this.bufRender.ctx.fillText("" + this.surfaceId, 5, 10);
                this.bufRender.drawRegions(srfNode.collisions);
            }
            this.elmRender.init(this.bufRender.cnv);
        };
        Surface.prototype.play = function (animationId, callback) {
            var _this = this;
            var anims = this.surfaceTreeNode.animations;
            var anim = this.surfaceTreeNode.animations[animationId];
            if (!anim)
                return void setTimeout(callback);
            // lazyPromises: [()=> Promise<void>, ()=> Promise<void>, ...]
            var lazyPromises = anim.patterns.map(function (pattern) { return function () { return new Promise(function (resolve, reject) {
                var surface = pattern.surface, wait = pattern.wait, type = pattern.type, x = pattern.x, y = pattern.y, animation_ids = pattern.animation_ids;
                switch (type) {
                    case "start":
                        _this.play(animation_ids[0], function () { return resolve(Promise.resolve()); });
                        return;
                    case "stop":
                        _this.stop(animation_ids[0]);
                        setTimeout(function () { return resolve(Promise.resolve()); });
                        return;
                    case "alternativestart":
                        _this.play(cuttlebone.SurfaceUtil.choice(animation_ids), function () { return resolve(Promise.resolve()); });
                        return;
                    case "alternativestart":
                        _this.stop(cuttlebone.SurfaceUtil.choice(animation_ids));
                        setTimeout(function () { return resolve(Promise.resolve()); });
                        return;
                }
                _this.layers[animationId] = pattern;
                _this.render();
                var _a = (/(\d+)(?:\-(\d+))?/.exec(wait) || ["", "0"]), __ = _a[0], a = _a[1], b = _a[2];
                var _wait = isFinite(Number(b))
                    ? randomRange(Number(a), Number(b))
                    : Number(a);
                setTimeout((function () {
                    if (_this.destructed) {
                        reject(null);
                    }
                    else {
                        resolve(Promise.resolve());
                    }
                }), _wait);
            }); }; });
            var promise = lazyPromises.reduce((function (proA, proB) { return proA.then(proB); }), Promise.resolve()); // Promise.resolve().then(prom).then(prom)...
            promise
                .then(function () { return setTimeout(callback); })
                .catch(function (err) { if (!!err)
                console.error(err.stack); });
        };
        Surface.prototype.stop = function (animationId) {
            this.stopFlags[animationId] = true;
        };
        Surface.prototype.talk = function () {
            var _this = this;
            var animations = this.surfaceTreeNode.animations;
            this.talkCount++;
            var hits = animations.filter(function (anim) {
                return /^talk/.test(anim.interval) && _this.talkCount % _this.talkCounts[anim.is] === 0;
            });
            hits.forEach(function (anim) {
                _this.play(anim.is);
            });
        };
        Surface.prototype.yenE = function () {
            var _this = this;
            var animations = this.surfaceTreeNode.animations;
            var hits = animations.filter(function (anim) {
                return anim.interval === "yen-e" && _this.talkCount % _this.talkCounts[anim.is] === 0;
            });
            hits.forEach(function (anim) {
                _this.play(anim.is);
            });
        };
        Surface.prototype.getRegion = function (offsetX, offsetY) {
            var _this = this;
            if (cuttlebone.SurfaceUtil.isHit(this.element, offsetX, offsetY)) {
                var hitCols = this.surfaceTreeNode.collisions.filter(function (collision, colId) {
                    var type = collision.type, name = collision.name, left = collision.left, top = collision.top, right = collision.right, bottom = collision.bottom, coordinates = collision.coordinates, radius = collision.radius, center_x = collision.center_x, center_y = collision.center_y;
                    switch (type) {
                        case "rect":
                            return (left < offsetX && offsetX < right && top < offsetY && offsetY < bottom) ||
                                (right < offsetX && offsetX < left && bottom < offsetX && offsetX < top);
                        case "ellipse":
                            var width = Math.abs(right - left);
                            var height = Math.abs(bottom - top);
                            return Math.pow((offsetX - (left + width / 2)) / (width / 2), 2) +
                                Math.pow((offsetY - (top + height / 2)) / (height / 2), 2) < 1;
                        case "circle":
                            return Math.pow((offsetX - center_x) / radius, 2) + Math.pow((offsetY - center_y) / radius, 2) < 1;
                        case "polygon":
                            var ptC = { x: offsetX, y: offsetY };
                            var tuples = coordinates.reduce((function (arr, _a, i) {
                                var x = _a.x, y = _a.y;
                                arr.push([
                                    coordinates[i],
                                    (!!coordinates[i + 1] ? coordinates[i + 1] : coordinates[0])
                                ]);
                                return arr;
                            }), []);
                            var deg = tuples.reduce((function (sum, _a) {
                                var ptA = _a[0], ptB = _a[1];
                                var vctA = [ptA.x - ptC.x, ptA.y - ptC.y];
                                var vctB = [ptB.x - ptC.x, ptB.y - ptC.y];
                                var dotP = vctA[0] * vctB[0] + vctA[1] * vctB[1];
                                var absA = Math.sqrt(vctA.map(function (a) { return Math.pow(a, 2); }).reduce(function (a, b) { return a + b; }));
                                var absB = Math.sqrt(vctB.map(function (a) { return Math.pow(a, 2); }).reduce(function (a, b) { return a + b; }));
                                var rad = Math.acos(dotP / (absA * absB));
                                return sum + rad;
                            }), 0);
                            return deg / (2 * Math.PI) >= 1;
                        default:
                            console.warn("unkown collision type:", _this.surfaceId, colId, name, collision);
                            return false;
                    }
                });
                if (hitCols.length > 0)
                    return { isHit: true, name: hitCols[hitCols.length - 1].name };
                return { isHit: true, name: "" };
            }
            else {
                return { isHit: false, name: "" };
            }
        };
        return Surface;
    })();
    cuttlebone.Surface = Surface;
})(cuttlebone || (cuttlebone = {}));
/// <reference path="./PNGReader"/>
/// <reference path="../typings/bluebird/bluebird.d.ts"/>
var cuttlebone;
(function (cuttlebone) {
    var SurfaceUtil;
    (function (SurfaceUtil) {
        SurfaceUtil.enablePNGjs = true;
        function choice(arr) {
            return arr[Math.round(Math.random() * (arr.length - 1))];
        }
        SurfaceUtil.choice = choice;
        function copy(cnv) {
            var _copy = document.createElement("canvas");
            var ctx = _copy.getContext("2d");
            _copy.width = cnv.width;
            _copy.height = cnv.height;
            ctx.drawImage(cnv, 0, 0); // type hack
            return _copy;
        }
        SurfaceUtil.copy = copy;
        function fetchPNGUint8ClampedArrayFromArrayBuffer(pngbuf, pnabuf) {
            return new Promise(function (resolve, reject) {
                var reader = new cuttlebone.PNGReader(pngbuf);
                var png = reader.parse();
                var dataA = png.getUint8ClampedArray();
                if (typeof pnabuf === "undefined") {
                    var r = dataA[0], g = dataA[1], b = dataA[2], a = dataA[3];
                    var i = 0;
                    if (a !== 0) {
                        while (i < dataA.length) {
                            if (r === dataA[i] && g === dataA[i + 1] && b === dataA[i + 2]) {
                                dataA[i + 3] = 0;
                            }
                            i += 4;
                        }
                    }
                    return resolve(Promise.resolve({ width: png.width, height: png.height, data: dataA }));
                }
                var pnareader = new cuttlebone.PNGReader(pnabuf);
                var pna = pnareader.parse();
                var dataB = pna.getUint8ClampedArray();
                if (dataA.length !== dataB.length) {
                    return reject("fetchPNGUint8ClampedArrayFromArrayBuffer TypeError: png" +
                        png.width + "x" + png.height + " and  pna" + pna.width + "x" + pna.height +
                        " do not match both sizes");
                }
                var j = 0;
                while (j < dataA.length) {
                    dataA[j + 3] = dataB[j];
                    j += 4;
                }
                return resolve(Promise.resolve({ width: png.width, height: png.height, data: dataA }));
            }).catch(function (err) {
                return Promise.reject("fetchPNGUint8ClampedArrayFromArrayBuffer msg:" + err + ", reason: " + err.stack);
            });
        }
        SurfaceUtil.fetchPNGUint8ClampedArrayFromArrayBuffer = fetchPNGUint8ClampedArrayFromArrayBuffer;
        function fetchImageFromArrayBuffer(buffer, mimetype) {
            var url = URL.createObjectURL(new Blob([buffer], { type: mimetype || "image/png" }));
            return fetchImageFromURL(url).then(function (img) {
                URL.revokeObjectURL(url);
                return Promise.resolve(img);
            }).catch(function (err) {
                return Promise.reject("fetchImageFromArrayBuffer > " + err);
            });
        }
        SurfaceUtil.fetchImageFromArrayBuffer = fetchImageFromArrayBuffer;
        function fetchImageFromURL(url) {
            var img = new Image();
            img.src = url;
            return new Promise(function (resolve, reject) {
                img.addEventListener("load", function () {
                    resolve(Promise.resolve(img)); // type hack
                });
                img.addEventListener("error", function (ev) {
                    console.error("fetchImageFromURL", ev);
                    reject("fetchImageFromURL ");
                });
            });
        }
        SurfaceUtil.fetchImageFromURL = fetchImageFromURL;
        function random(callback, probability) {
            var ms = 1;
            while (Math.round(Math.random() * 1000) > 1000 / probability) {
                ms++;
            }
            setTimeout((function () {
                return callback(function () { return random(callback, probability); });
            }), ms * 1000);
        }
        SurfaceUtil.random = random;
        function periodic(callback, sec) {
            setTimeout((function () {
                return callback(function () {
                    return periodic(callback, sec);
                });
            }), sec * 1000);
        }
        SurfaceUtil.periodic = periodic;
        function always(callback) {
            callback(function () { return always(callback); });
        }
        SurfaceUtil.always = always;
        function isHit(cnv, x, y) {
            var ctx = cnv.getContext("2d");
            var imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
            var data = imgdata.data;
            return data[data.length - 1] !== 0;
        }
        SurfaceUtil.isHit = isHit;
        function offset(element) {
            var obj = element.getBoundingClientRect();
            return {
                left: obj.left + window.pageXOffset,
                top: obj.top + window.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            };
        }
        SurfaceUtil.offset = offset;
        function createCanvas() {
            var cnv = document.createElement("canvas");
            cnv.width = 1;
            cnv.height = 1;
            return cnv;
        }
        SurfaceUtil.createCanvas = createCanvas;
        function scope(scopeId) {
            return scopeId === 0 ? "sakura"
                : scopeId === 1 ? "kero"
                    : "char" + scopeId;
        }
        SurfaceUtil.scope = scope;
        /*
        var _charId = charId === "sakura" ? 0
                    : charId === "kero"   ? 1
                    : Number(/^char(\d+)/.exec(charId)[1]);
        */
        /*
        @isHitBubble = (element, pageX, pageY)->
          $(element).hide()
          elm = document.elementFromPoint(pageX, pageY)
          if !elm
            $(element).show(); return elm
          unless elm instanceof HTMLCanvasElement
            $(element).show(); return elm
          {top, left} = $(elm).offset()
          if Surface.isHit(elm, pageX-left, pageY-top)
            $(element).show(); return elm
          _elm = Surface.isHitBubble(elm, pageX, pageY)
          $(element).show(); return _elm
        */
        function elementFromPointWithout(element, pageX, pageY) {
            var tmp = element.style.display;
            element.style.display = "none";
            // elementを非表示にして直下の要素を調べる
            var elm = document.elementFromPoint(pageX, pageY);
            // 直下の要素がcanvasなら透明かどうか調べる
            // todo: cuttlebone管理下の要素かどうかの判定必要
            if (!elm) {
                element.style.display = tmp;
                return elm;
            }
            if (!(elm instanceof HTMLCanvasElement)) {
                element.style.display = tmp;
                return elm;
            }
            var _a = offset(elm), top = _a.top, left = _a.left;
            // 不透明canvasならヒット
            if (elm instanceof HTMLCanvasElement && isHit(elm, pageX - left, pageY - top)) {
                element.style.display = tmp;
                return elm;
            }
            if (elm instanceof HTMLElement) {
                // elementの非表示のままさらに下の要素を調べにいく
                var _elm = elementFromPointWithout(elm, pageX, pageY);
                element.style.display = tmp;
                return _elm;
            }
            // 解決できなかった！ザンネン!
            console.warn(elm);
            element.style.display = tmp;
            return null;
        }
        SurfaceUtil.elementFromPointWithout = elementFromPointWithout;
    })(SurfaceUtil = cuttlebone.SurfaceUtil || (cuttlebone.SurfaceUtil = {}));
})(cuttlebone || (cuttlebone = {}));
var cuttlebone;
(function (cuttlebone) {
    var SurfaceRender = (function () {
        function SurfaceRender(cnv) {
            this.cnv = cnv;
            this.ctx = cnv.getContext("2d");
        }
        SurfaceRender.prototype.composeElements = function (elements) {
            if (elements.length === 0) {
                return;
            }
            if (!Array.isArray(elements))
                throw new Error("TypeError: elements is not array.");
            // elements is a array but it is like `a=[];a[2]="hoge";a[0] === undefined. so use filter.`
            var _a = elements.filter(function (elm) { return !!elm; })[0], canvas = _a.canvas, type = _a.type, x = _a.x, y = _a.y;
            var offsetX = 0;
            var offsetY = 0;
            switch (type) {
                case "base":
                    this.base(canvas);
                    break;
                case "overlay":
                case "add":
                case "bind":
                    this.overlay(canvas, offsetX + x, offsetY + y);
                    break;
                case "overlayfast":
                    this.overlayfast(canvas, offsetX + x, offsetY + y);
                    break;
                case "replace":
                    this.replace(canvas, offsetX + x, offsetY + y);
                    break;
                case "interpolate":
                    this.interpolate(canvas, offsetX + x, offsetY + y);
                    break;
                case "move":
                    offsetX = x;
                    offsetY = y;
                    var copyed = cuttlebone.SurfaceUtil.copy(this.cnv);
                    this.base(copyed);
                    break;
                case "asis":
                case "reduce":
                case "insert,ID": break;
                default:
                    console.error(elements[0]);
            }
            this.composeElements(elements.slice(1));
        };
        SurfaceRender.prototype.clear = function () {
            this.cnv.width = this.cnv.width;
        };
        SurfaceRender.prototype.chromakey = function () {
            var ctx = this.cnv.getContext("2d");
            var imgdata = ctx.getImageData(0, 0, this.cnv.width, this.cnv.height);
            var data = imgdata.data;
            var r = data[0], g = data[1], b = data[2], a = data[3];
            var i = 0;
            if (a !== 0) {
                while (i < data.length) {
                    if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
                        data[i + 3] = 0;
                    }
                    i += 4;
                }
            }
            ctx.putImageData(imgdata, 0, 0);
        };
        SurfaceRender.prototype.pna = function (pna) {
            var ctxB = pna.getContext("2d");
            var imgdataA = this.ctx.getImageData(0, 0, this.cnv.width, this.cnv.height);
            var imgdataB = ctxB.getImageData(0, 0, pna.width, pna.height);
            var dataA = imgdataA.data;
            var dataB = imgdataB.data;
            var i = 0;
            while (i < dataA.length) {
                dataA[i + 3] = dataB[i];
                i += 4;
            }
            this.ctx.putImageData(imgdataA, 0, 0);
        };
        SurfaceRender.prototype.base = function (part) {
            this.init(part);
        };
        SurfaceRender.prototype.overlay = function (part, x, y) {
            if (this.cnv.width < part.width || this.cnv.height < part.height) {
                this.init(part);
            }
            else {
                this.ctx.globalCompositeOperation = "source-over";
                this.ctx.drawImage(part, x, y);
            }
        };
        SurfaceRender.prototype.overlayfast = function (part, x, y) {
            this.ctx.globalCompositeOperation = "source-atop";
            this.ctx.drawImage(part, x, y);
        };
        SurfaceRender.prototype.interpolate = function (part, x, y) {
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.drawImage(part, x, y);
        };
        SurfaceRender.prototype.replace = function (part, x, y) {
            this.ctx.clearRect(x, y, part.width, part.height);
            this.overlay(part, x, y);
        };
        SurfaceRender.prototype.init = function (cnv) {
            this.cnv.width = cnv.width;
            this.cnv.height = cnv.height;
            this.overlay(cnv, 0, 0); // type hack
        };
        SurfaceRender.prototype.initImageData = function (width, height, data) {
            this.cnv.width = width;
            this.cnv.height = height;
            var imgdata = this.ctx.getImageData(0, 0, width, height);
            var _data = imgdata.data; // type hack
            _data.set(data);
            this.ctx.putImageData(imgdata, 0, 0);
        };
        SurfaceRender.prototype.drawRegions = function (regions) {
            var _this = this;
            regions.forEach(function (col) {
                _this.drawRegion(col);
            });
        };
        SurfaceRender.prototype.drawRegion = function (region) {
            var type = region.type, name = region.name, left = region.left, top = region.top, right = region.right, bottom = region.bottom, coordinates = region.coordinates, radius = region.radius, center_x = region.center_x, center_y = region.center_y;
            this.ctx.strokeStyle = "#00FF00";
            switch (type) {
                case "rect":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "ellipse":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "circle":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "polygon":
                    this.ctx.rect(left, top, right - left, bottom - top);
            }
            this.ctx.stroke();
            this.ctx.font = "35px";
            this.ctx.strokeStyle = "white";
            this.ctx.strokeText(type + ":" + name, left + 5, top + 10);
            this.ctx.fillStyle = "black";
            this.ctx.fillText(type + ":" + name, left + 5, top + 10);
        };
        return SurfaceRender;
    })();
    cuttlebone.SurfaceRender = SurfaceRender;
})(cuttlebone || (cuttlebone = {}));
// Generated by CoffeeScript 1.9.2
(function() {
  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = cuttlebone;
  }

}).call(this);
