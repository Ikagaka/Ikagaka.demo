// Generated by CoffeeScript 1.9.2

/* (C) 2015 Legokichi : Licensed under The MIT License */

(function() {
  var $, Balloon, BalloonSurface, Encoding, Named, NamedManager, Scope, Shell, Surface, SurfaceUtil, SurfacesTxt2Yaml, Util, _, cuttlebone, global,
    slice = [].slice;

  global = (this || 0).self || global;

  Encoding = global["Encoding"] || require("encoding-japanese");

  SurfacesTxt2Yaml = global["SurfacesTxt2Yaml"] || require("surfaces_txt2yaml");

  _ = global["_"] || require("lodash");

  $ = global["Zepto"] || require("zepto");

  Util = {
    convert: function(buffer) {
      return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
    },
    parseDescript: function (text){
    // @arg String
    // @ret {[id: String]: String;}
    text = text.replace(/(?:\r\n|\r|\n)/g, "\n"); // CRLF->LF
    while(true){// remove commentout
      var match = (/(?:(?:^|\s)\/\/.*)|^\s+?$/g.exec(text) || ["",""])[0];
      if(match.length === 0) break;
      text = text.replace(match, "");
    }
    var lines = text.split("\n");
    lines = lines.filter(function(line){ return line.length !== 0; }); // remove no content line
    var dic = lines.reduce(function(dic, line){
      var tmp = line.split(",");
      var key = tmp[0];
      var vals = tmp.slice(1);
      key = key.trim();
      var val = vals.join(",").trim();
      dic[key] = val;
      return dic;
    }, {});
    return dic;
  }
  };

  Balloon = (function() {
    function Balloon(directory) {
      this.directory = directory;
      this.descript = null;
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      var prm;
      if (!!this.directory["descript.txt"]) {
        this.descript = Util.parseDescript(Util.convert(this.directory["descript.txt"]));
      } else {
        this.descript = {};
        console.warn("descript.txt is not found");
      }
      prm = Promise.resolve(this.balloons);
      prm = prm.then(Balloon.loadBalloonSurfaces(this.directory));
      prm = prm.then(Balloon.loadBalloonDescripts(this.directory, this.descript));
      prm = prm.then((function(_this) {
        return function(balloons) {
          _this.balloons = balloons;
          _this.directory = null;
          return _this;
        };
      })(this));
      prm = prm["catch"](function(err) {
        console.error(err);
        err.message && console.error(err.message);
        err.stack && console.error(err.stack);
        throw err;
      });
      return prm;
    };

    Balloon.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][surfaceId] == null) {
        return null;
      }
      return new BalloonSurface(canvas, scopeId, this.balloons[type][surfaceId], this.balloons);
    };

    Balloon.loadBalloonDescripts = function(directory, descript) {
      return function(balloons) {
        return new Promise(function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref, type;
            buffer = directory[filepath];
            _descript = Util.parseDescript(Util.convert(buffer));
            ref = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = $.extend(true, _descript, descript);
              case "k":
                return balloons["kero"][Number(n)].descript = $.extend(true, _descript, descript);
            }
          });
          return resolve(balloons);
        });
      };
    };

    Balloon.loadBalloonSurfaces = function(directory) {
      return function(balloons) {
        var hits, keys, promises;
        keys = Object.keys(directory);
        hits = keys.filter(function(filepath) {
          return /[^\/]+\.png$/.test(filepath);
        });
        promises = hits.map(function(filepath) {
          return new Promise(function(resolve, reject) {
            var buffer, url;
            buffer = directory[filepath];
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return SurfaceUtil.loadImage(url, function(err, img) {
              var __, n, ref, ref1, ref2, type;
              if (!!err) {
                return reject(err);
              }
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err);
              }
              if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
                ref = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
                switch (type) {
                  case "s":
                    balloons["sakura"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                    break;
                  case "k":
                    balloons["kero"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                    break;
                  case "c":
                    balloons["communicate"][Number(n)] = {
                      canvas: SurfaceUtil.transImage(img)
                    };
                }
              } else if (/^online(\d+)\.png$/.test(filepath)) {
                ref1 = /^online(\d+)\.png$/.exec(filepath), __ = ref1[0], n = ref1[1];
                balloons["online"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^arrow(\d+)\.png$/.test(filepath)) {
                ref2 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
                balloons["arrow"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^sstp\.png$/.test(filepath)) {
                balloons["sstp"] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              } else if (/^thumbnail\.png$/.test(filepath)) {
                balloons["thumbnail"] = {
                  canvas: SurfaceUtil.transImage(img)
                };
              }
              return resolve();
            });
          });
        });
        return new Promise(function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(balloons);
          });
        });
      };
    };

    return Balloon;

  })();

  BalloonSurface = (function() {
    function BalloonSurface(element1, scopeId1, balloonConf, balloons1) {
      this.element = element1;
      this.scopeId = scopeId1;
      this.balloons = balloons1;
      this.descript = balloonConf.descript;
      this.baseCanvas = balloonConf.canvas;
      this.render();
    }

    BalloonSurface.prototype.destructor = function() {};

    BalloonSurface.prototype.render = function() {
      var type, util;
      type = this.scopeId === 0 ? "sakura" : "kero";
      util = new SurfaceUtil(this.element);
      util.init(this.baseCanvas);
    };

    return BalloonSurface;

  })();

  Named = (function() {
    function Named(shell1, balloon1) {
      this.shell = shell1;
      this.balloon = balloon1;
      this.$named = $("<div />").addClass("named");
      this.element = this.$named[0];
      this.scopes = [];
      this.currentScope = null;
      this.destructors = [];
      this.listener = {};
    }

    Named.prototype.load = function() {
      this.scopes[0] = this.scope(0);
      this.currentScope = this.scopes[0];
      $(this.element).on("IkagakaDOMEvent", (function(_this) {
        return function(arg) {
          var event;
          event = arg.detail;
          return _this.trigger(event.type, event);
        };
      })(this));
      (function(_this) {
        return (function() {
          var $body, $target, onmousedown, onmousemove, onmouseup, relLeft, relTop;
          $target = null;
          relLeft = relTop = 0;
          onmouseup = function(ev) {
            var ref, ref1;
            if (!!$target) {
              if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
                if ($target[0] === ((ref = $(ev.target).parent()) != null ? ref[0] : void 0)) {
                  return $target = null;
                }
              } else if ($(ev.target).hasClass("surfaceCanvas")) {
                if ($target[0] === ((ref1 = $(ev.target).parent().parent()) != null ? ref1[0] : void 0)) {
                  return $target = null;
                }
              }
            }
          };
          onmousedown = function(ev) {
            var $scope, left, offsetX, offsetY, pageX, pageY, ref, ref1, ref2, ref3, top;
            if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
              if (((ref = $(ev.target).parent().parent().parent()) != null ? ref[0] : void 0) === _this.element) {
                $target = $(ev.target).parent();
                $scope = $target.parent();
                ref1 = $target.offset(), top = ref1.top, left = ref1.left;
                offsetY = parseInt($target.css("left"), 10);
                offsetX = parseInt($target.css("top"), 10);
                if (/^touch/.test(ev.type)) {
                  pageX = ev.touches[0].pageX;
                  pageY = ev.touches[0].pageY;
                } else {
                  pageX = ev.pageX;
                  pageY = ev.pageY;
                }
                relLeft = pageX - offsetY;
                relTop = pageY - offsetX;
                return setTimeout((function() {
                  return _this.$named.append($scope);
                }), 200);
              }
            } else if ($(ev.target).hasClass("surfaceCanvas")) {
              if (((ref2 = $(ev.target).parent().parent().parent()) != null ? ref2[0] : void 0) === _this.element) {
                $scope = $target = $(ev.target).parent().parent();
                ref3 = $target.offset(), top = ref3.top, left = ref3.left;
                if (/^touch/.test(ev.type)) {
                  pageX = ev.touches[0].pageX;
                  pageY = ev.touches[0].pageY;
                } else {
                  pageX = ev.pageX;
                  pageY = ev.pageY;
                }
                relLeft = pageX - left;
                relTop = pageY - top;
                return setTimeout((function() {
                  return _this.$named.append($scope);
                }), 200);
              }
            }
          };
          onmousemove = function(ev) {
            var pageX, pageY;
            if (!!$target) {
              if (/^touch/.test(ev.type)) {
                pageX = ev.touches[0].pageX;
                pageY = ev.touches[0].pageY;
              } else {
                pageX = ev.pageX;
                pageY = ev.pageY;
              }
              return $target.css({
                left: pageX - relLeft,
                top: pageY - relTop
              });
            }
          };
          $body = $("body");
          $body.on("mousedown", onmousedown);
          $body.on("mousemove", onmousemove);
          $body.on("mouseup", onmouseup);
          $body.on("touchstart", onmousedown);
          $body.on("touchmove", onmousemove);
          $body.on("touchend", onmouseup);
          return _this.destructors.push(function() {
            $body.off("mousedown", onmousedown);
            $body.off("mousemove", onmousemove);
            $body.off("mouseup", onmouseup);
            $body.off("touchstart", onmousedown);
            $body.off("touchmove", onmousemove);
            return $body.off("touchend", onmouseup);
          });
        });
      })(this)();
      (function(_this) {
        return (function() {
          var onblimpclick, onblimpdblclick;
          onblimpclick = function(ev) {
            var event;
            event = {
              type: "balloonclick"
            };
            return _this.trigger(event.type, event);
          };
          onblimpdblclick = function(ev) {
            var event;
            event = {
              type: "balloondblclick"
            };
            return _this.trigger(event.type, event);
          };
          _this.$named.on("click", ".blimp", onblimpclick);
          _this.$named.on("dblclick", ".blimp", onblimpdblclick);
          return _this.destructors.push(function() {
            _this.$named.off("click", ".blimp", onblimpclick);
            return _this.$named.off("dblclick", ".blimp", onblimpdblclick);
          });
        });
      })(this)();
      (function(_this) {
        return (function() {
          var onanchorclick, onchoiceclick;
          onchoiceclick = function(ev) {
            var argc, event, i, j, ref;
            event = {};
            event.type = "choiceselect";
            event.id = ev.target.dataset["id"];
            event.args = [];
            event.text = ev.target.textContent;
            argc = Number(ev.target.dataset["argc"]);
            for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              event.args.push(ev.target.dataset["argv" + i]);
            }
            return _this.trigger(event.type, event);
          };
          onanchorclick = function(ev) {
            var argc, event, i, j, ref;
            event = {};
            event.type = "anchorselect";
            event.id = ev.target.dataset["id"];
            event.args = [];
            event.text = ev.target.textContent;
            argc = Number(ev.target.dataset["argc"]);
            for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              event.args.push(ev.target.dataset["argv" + i]);
            }
            return _this.trigger(event.type, event);
          };
          _this.$named.on("click", ".ikagaka-choice", onchoiceclick);
          _this.$named.on("click", ".ikagaka-anchor", onanchorclick);
          return _this.destructors.push(function() {
            _this.$named.off("click", ".ikagaka-choice", onchoiceclick);
            return _this.$named.off("click", ".ikagaka-anchor", onanchorclick);
          });
        });
      })(this)();
      return Promise.resolve(this);
    };

    Named.prototype.destructor = function() {
      this.scopes.forEach(function(scope) {
        return $(scope.element).remove();
      });
      this.destructors.forEach(function(destructor) {
        return destructor();
      });
      this.$named.remove();
    };

    Named.prototype.scope = function(scopeId) {
      if (!isFinite(scopeId)) {
        return this.currentScope;
      }
      if (!this.scopes[scopeId]) {
        this.scopes[scopeId] = new Scope(scopeId, this.shell, this.balloon);
      }
      this.currentScope = this.scopes[scopeId];
      this.$named.append(this.scopes[scopeId].element);
      return this.currentScope;
    };

    Named.prototype.openInputBox = function(id, text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "userinput",
        "id": id,
        "content": prompt("UserInput", text)
      };
      this.trigger(event.type, event);
    };

    Named.prototype.openCommunicateBox = function(text) {
      var event;
      if (text == null) {
        text = "";
      }
      event = {
        "type": "communicateinput",
        "sender": "user",
        "content": prompt("Communicate", text)
      };
      this.trigger(event.type, event);
    };

    Named.prototype.on = function(event, callback) {
      if (!((event != null) && (callback != null))) {
        throw Error('on() event and callback required');
      }
      if (this.listener == null) {
        this.listener = {};
      }
      if (this.listener[event] == null) {
        this.listener[event] = [];
      }
      if (-1 === this.listener[event].indexOf(callback)) {
        this.listener[event].push(callback);
      }
      return this;
    };

    Named.prototype.off = function(event, callback) {
      var index;
      if ((event != null) && (callback != null)) {
        if (this.listener[event] != null) {
          index = this.listener[event].indexOf(callback);
          if (index !== -1) {
            this.listener[event].splice(index, 1);
          }
        }
      } else if (event != null) {
        delete this.listener[event];
      } else if (callback != null) {
        for (event in this.listener) {
          index = this.listener[event].indexOf(callback);
          if (index !== -1) {
            this.listener[event].splice(index, 1);
          }
        }
      } else {
        delete this.listener;
      }
      return this;
    };

    Named.prototype.trigger = function() {
      var args, callback, event, j, len, ref, ref1;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (((ref = this.listener) != null ? ref[event] : void 0) != null) {
        ref1 = this.listener[event];
        for (j = 0, len = ref1.length; j < len; j++) {
          callback = ref1[j];
          setTimeout((function() {
            return callback.apply(this, args);
          }), 0);
        }
      }
      return this;
    };

    return Named;

  })();

  NamedManager = (function() {
    function NamedManager() {
      var $style;
      console.log($);
      this.$namedMgr = $("<div />").addClass("namedMgr");
      $style = $("<style scoped />").html(this.style);
      this.$namedMgr.append($style);
      this.element = this.$namedMgr[0];
      this.namedies = [];
      this.destructors = [];
      (function(_this) {
        return (function() {
          var onmousedown;
          onmousedown = function(ev) {
            return setTimeout((function() {
              return _this.$namedMgr.append(ev.currentTarget);
            }), 300);
          };
          _this.$namedMgr.on("mousedown", ".named", onmousedown);
          _this.$namedMgr.on("touchstart", ".named", onmousedown);
          return _this.destructors.push(function() {
            _this.$namedMgr.off("mousedown", ".named", onmousedown);
            return _this.$namedMgr.off("touchstart", ".named", onmousedown);
          });
        });
      })(this)();
    }

    NamedManager.prototype.destructor = function() {
      this.namedies.filter(function(named) {
        return named != null;
      }).forEach(function(named) {
        return $(named.element).remove();
      });
      this.destructors.forEach(function(destructor) {
        return destructor();
      });
      this.$namedMgr.remove();
    };

    NamedManager.prototype.materialize = function(shell, balloon) {
      var named;
      named = new Named(shell, balloon);
      this.namedies.push(named);
      this.$namedMgr.append(named.element);
      return this.namedies.length - 1;
    };

    NamedManager.prototype.vanish = function(namedId) {
      if (this.namedies[namedId] == null) {
        throw new Error("namedId " + namedId + " is not used yet");
      }
      this.namedies[namedId].destructor();
      this.namedies[namedId] = null;
    };

    NamedManager.prototype.named = function(namedId) {
      if (this.namedies[namedId] == null) {
        throw new Error("namedId " + namedId + " is not used yet");
      }
      return this.namedies[namedId];
    };

    NamedManager.prototype.style = ".scope {\n  position: absolute;\n  pointer-events: none;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n.surface {\n}\n.surfaceCanvas {\n  pointer-events: auto;\n}\n.blimp {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  pointer-events: auto;\n}\n.blimpCanvas {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.blimpText {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow-y: scroll;\n  white-space: pre-wrap;\n  word-wrap: break-all;\n}\n.blimpText a {\n  cursor: pointer;\n}\n\n@keyframes blink {\n  75% { opacity: 0.0; }\n}\n.blink {\n  animation: blink 1s step-end infinite;\n}";

    return NamedManager;

  })();

  Scope = (function() {
    function Scope(scopeId1, shell1, balloon1) {
      var clickable_element_style, descript, styles;
      this.scopeId = scopeId1;
      this.shell = shell1;
      this.balloon = balloon1;
      this.$scope = $("<div />").addClass("scope");
      this.$surface = $("<div />").addClass("surface");
      this.$surfaceCanvas = $("<canvas width='10' height='100' />").addClass("surfaceCanvas");
      this.$blimp = $("<div />").addClass("blimp");
      this.$blimpCanvas = $("<canvas width='0' height='0' />").addClass("blimpCanvas");
      this.$blimpText = $("<div />").addClass("blimpText");
      descript = this.balloon.descript;
      styles = {};
      styles["cursor"] = descript["cursor"] || '';
      styles["font.name"] = (descript["font.name"] || "MS Gothic").split(/,/).map(function(name) {
        return '"' + name + '"';
      }).join(',');
      styles["font.height"] = (descript["font.height"] || "12") + "px";
      styles["font.color"] = this._getFontColor(descript["font.color.r"], descript["font.color.g"], descript["font.color.b"]);
      styles["font.shadowcolor"] = this._getFontColor(descript["font.shadowcolor.r"], descript["font.shadowcolor.g"], descript["font.shadowcolor.b"], true);
      styles["font.bold"] = descript["font.bold"];
      styles["font.italic"] = descript["font.italic"];
      styles["font.strike"] = descript["font.strike"];
      styles["font.underline"] = descript["font.underline"];
      this._text_style = styles;
      clickable_element_style = (function(_this) {
        return function(prefix, style_default, descript, can_ignore) {
          styles = {};
          styles["style"] = {
            square: true,
            underline: true,
            'square+underline': true,
            none: true
          }[descript[prefix + ".style"]] ? descript[prefix + ".style"] : style_default;
          styles["font.color"] = _this._getFontColor(descript[prefix + ".font.color.r"], descript[prefix + ".font.color.g"], descript[prefix + ".font.color.b"], can_ignore);
          styles["pen.color"] = _this._getFontColor(descript[prefix + ".pen.color.r"], descript[prefix + ".pen.color.g"], descript[prefix + ".pen.color.b"], can_ignore);
          styles["brush.color"] = _this._getFontColor(descript[prefix + ".brush.color.r"], descript[prefix + ".brush.color.g"], descript[prefix + ".brush.color.b"], can_ignore);
          return styles;
        };
      })(this);
      this._choice_style = clickable_element_style("cursor", "square", descript);
      this._choice_notselect_style = clickable_element_style("cursor.notselect", void 0, descript, true);
      this._anchor_style = clickable_element_style("anchor", "underline", descript);
      this._anchor_notselect_style = clickable_element_style("anchor.notselect", void 0, descript, true);
      this.$blimpText.css(this._blimpTextCSS(this._text_style));
      this._initializeCurrentStyle();
      this.element = this.$scope[0];
      this.destructors = [];
      this.currentSurface = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, 0);
      this.currentBalloon = this.balloon.attachSurface(this.$blimpCanvas[0], this.scopeId, 0);
      this.isBalloonLeft = true;
      this.insertPoint = this.$blimpText;
      this.$blimp.append(this.$blimpCanvas);
      this.$blimp.append(this.$blimpText);
      this.$surface.append(this.$surfaceCanvas);
      this.$scope.append(this.$surface);
      this.$scope.append(this.$blimp);
      this.$scope.css({
        "bottom": "0px",
        "right": (this.scopeId * 240) + "px"
      });
      this.surface(0);
      this.blimp(0);
      this.surface(-1);
      this.blimp(-1);
    }

    Scope.prototype.surface = function(surfaceId) {
      var prevSrfId, tmp, type;
      type = this.scopeId === 0 ? "sakura" : "kero";
      if (Number(surfaceId) < 0) {
        this.$surface.hide();
        return this.currentSurface;
      }
      if (surfaceId != null) {
        prevSrfId = this.currentSurface.surfaces.surfaces[this.currentSurface.surfaceName].is;
        this.currentSurface.destructor();
        tmp = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, surfaceId);
        if (!tmp) {
          tmp = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, prevSrfId);
        }
        this.currentSurface = tmp;
        this.$scope.width(this.$surfaceCanvas[0].width);
        this.$scope.height(this.$surfaceCanvas[0].height);
        this.$surface.show();
      }
      return this.currentSurface;
    };

    Scope.prototype.blimp = function(balloonId) {
      var b, descript, h, l, location, r, t, tmp, type, w;
      if (Number(balloonId) < 0) {
        this.$blimp.hide();
      } else {
        if (balloonId != null) {
          this.currentBalloon.destructor();
          tmp = this.balloon.attachSurface(this.$blimpCanvas[0], this.scopeId, balloonId);
          this.currentBalloon = tmp;
          this.$blimp.width(this.$blimpCanvas[0].width);
          this.$blimp.height(this.$blimpCanvas[0].height);
          this.$blimp.show();
          descript = this.currentBalloon.descript;
          type = this.scopeId === 0 ? "sakura" : "kero";
          this.$blimp.css({
            "top": Number(this.shell.descript[type + ".balloon.offsety"] || 0)
          });
          if (this.isBalloonLeft) {
            this.$blimp.css({
              "left": Number(this.shell.descript[type + ".balloon.offsetx"] || 0) + -1 * this.$blimpCanvas[0].width
            });
          } else {
            this.$blimp.css({
              "left": Number(this.shell.descript[type + ".balloon.offsetx"] || 0) + this.$surfaceCanvas[0].width
            });
          }
          t = descript["origin.y"] || descript["validrect.top"] || "10";
          r = descript["validrect.right"] || "10";
          b = descript["validrect.bottom"] || "10";
          l = descript["origin.x"] || descript["validrect.left"] || "10";
          w = this.$blimpCanvas[0].width;
          h = this.$blimpCanvas[0].height;
          this.$blimpText.css({
            "top": t + "px",
            "left": l + "px",
            "width": (w - (Number(l) + Number(r))) + "px",
            "height": (h - (Number(t) - Number(b))) + "px"
          });
        }
      }
      location = (function(_this) {
        return function(x, y) {
          var $imp_position_checker, $newimp, $newimp_container, $newimp_container_top, baseoffset, offset, offsetx, offsety, re, toparam, xp, yp;
          re = /^(@)?(-?\d*\.?\d*e?\d*)(em|%)?$/;
          toparam = function(r) {
            var rp, unit, value;
            if (!((r != null) && r.length)) {
              return {
                relative: true,
                value: 0
              };
            }
            rp = r.match(re);
            if (!rp) {
              return;
            }
            if (isNaN(rp[2])) {
              return;
            }
            if (rp[3] === '%') {
              value = rp[2] / 100;
              unit = 'em';
            } else {
              value = Number(rp[2]);
              unit = rp[3] || 'px';
            }
            return {
              relative: !!rp[1],
              value: value + unit
            };
          };
          xp = toparam(x);
          yp = toparam(y);
          if (!((xp != null) && (yp != null))) {
            return;
          }
          if (xp.relative || yp.relative) {
            $imp_position_checker = $('<span>.</span>');
            _this.insertPoint.append($imp_position_checker);
            offset = $imp_position_checker.offset();
            baseoffset = _this.$blimpText.offset();
            offsetx = offset.left - baseoffset.left;
            offsety = offset.top - baseoffset.top + _this.$blimpText.scrollTop();
            $imp_position_checker.remove();
          }
          if (!xp.relative) {
            offsetx = 0;
          }
          if (!yp.relative) {
            offsety = 0;
          }
          $newimp_container_top = $('<div />').css({
            'position': 'absolute',
            'pointer-events': 'none',
            'top': yp.value
          });
          $newimp_container = $('<div />').css({
            'position': 'absolute',
            'pointer-events': 'none',
            'text-indent': offsetx + 'px',
            'top': offsety + 'px',
            'width': _this.$blimpText[0].clientWidth
          });
          $newimp = $('<span />').css({
            'pointer-events': 'auto',
            'margin-left': xp.value
          });
          _this.insertPoint = $newimp.appendTo($newimp_container.appendTo($newimp_container_top.appendTo(_this.$blimpText)));
          return _this.insertPoint.css(_this._blimpTextCSS(_this._current_text_style));
        };
      })(this);
      return {
        anchorBegin: (function(_this) {
          return function() {
            var $a, _id, anchor_css, anchor_notselect_css, args, argv, id, index, j, len, text_css;
            id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-anchor");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            anchor_css = _this._blimpClickableTextCSS(_this._current_anchor_style);
            anchor_notselect_css = _this._blimpClickableTextCSS(_this._current_anchor_notselect_style, _this._current_anchor_style);
            $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(anchor_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
            });
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = j = 0, len = args.length; j < len; index = ++j) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            _this.originalInsertPoint = _this.insertPoint;
            _this.insertPoint = $a.appendTo(_this.insertPoint);
          };
        })(this),
        anchorEnd: (function(_this) {
          return function() {
            _this.insertPoint = _this.originalInsertPoint;
          };
        })(this),
        choice: (function(_this) {
          return function() {
            var $a, _id, _text, args, argv, choice_css, choice_notselect_css, id, index, j, len, text, text_css;
            text = arguments[0], id = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _text = $(document.createElement("div")).text(text).html();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-choice");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            choice_css = _this._blimpClickableTextCSS(_this._current_choice_style);
            choice_notselect_css = _this._blimpClickableTextCSS(_this._current_choice_notselect_style, _this._current_text_style);
            $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(choice_css.base).css(choice_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            });
            $a.html(_text);
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = j = 0, len = args.length; j < len; index = ++j) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            $a.appendTo(_this.insertPoint);
          };
        })(this),
        choiceBegin: (function(_this) {
          return function() {
            var $a, _id, args, argv, choice_css, choice_notselect_css, id, index, j, len, text_css;
            id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            _this.$blimpText.find(".blink").hide();
            _this.$blimp.show();
            _id = $(document.createElement("div")).text(id).html();
            $a = $("<a />");
            $a.addClass("ikagaka-choice");
            text_css = _this._blimpTextCSS(_this._current_text_style);
            choice_css = _this._blimpClickableTextCSS(_this._current_choice_style);
            choice_notselect_css = _this._blimpClickableTextCSS(_this._current_choice_notselect_style, _this._current_text_style);
            $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            $a.mouseover(function() {
              return $a.css(choice_css.base).css(choice_css.over);
            });
            $a.mouseout(function() {
              return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
            });
            $a.attr("data-id", _id);
            $a.attr("data-argc", args.length);
            for (index = j = 0, len = args.length; j < len; index = ++j) {
              argv = args[index];
              $a.attr("data-argv" + index, argv);
            }
            _this.originalInsertPoint = _this.insertPoint;
            _this.insertPoint = $a.appendTo(_this.insertPoint);
          };
        })(this),
        choiceEnd: (function(_this) {
          return function() {
            _this.insertPoint = _this.originalInsertPoint;
          };
        })(this),
        talk: (function(_this) {
          return function(text) {
            var _text;
            _this.$blimpText.find(".blink").hide();
            _text = $(document.createElement("div")).text(text).html();
            if (!!_this.currentSurface) {
              _this.currentSurface.talk();
            }
            _this.$blimp.show();
            _this.insertPoint.append(_text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        talkraw: (function(_this) {
          return function(text) {
            _this.$blimpText.find(".blink").hide();
            if (!!_this.currentSurface) {
              _this.currentSurface.talk();
            }
            _this.$blimp.show();
            _this.insertPoint.append(text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        marker: (function(_this) {
          return function() {
            var _text;
            _this.$blimpText.find(".blink").hide();
            _text = $(document.createElement("div")).text("・").html();
            _this.$blimp.show();
            _this.insertPoint.append(_text);
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        clear: (function(_this) {
          return function() {
            _this.$blimpText.html("");
            _this.insertPoint = _this.$blimpText;
            _this._initializeCurrentStyle();
          };
        })(this),
        br: (function(_this) {
          return function(ratio) {
            if (ratio != null) {
              location('0', '@' + ratio + 'em');
            } else {
              _this.insertPoint.append("<br />");
            }
          };
        })(this),
        showWait: (function(_this) {
          return function() {
            _this.$blimpText.append("<br /><br />").append("<div class='blink'>▼</div>");
            _this.$blimpText[0].scrollTop = 999;
          };
        })(this),
        font: (function(_this) {
          return function() {
            var $newimp, $size_checker, is_text_style, name, size, treat_bool, treat_clickable_styles, value, values;
            name = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            value = values[0];
            treat_bool = function(name, value) {
              if (value === 'default') {
                return _this._current_text_style["font." + name] = _this._text_style["font." + name];
              } else {
                return _this._current_text_style["font." + name] = !((value === 'false') || ((value - 0) === 0));
              }
            };
            treat_clickable_styles = function(treat_name, name, value, values, _current_style, _style) {
              switch (name) {
                case treat_name + "style":
                  if (value === 'default') {
                    return _current_style["style"] = _style["style"];
                  } else {
                    return _current_style["style"] = value;
                  }
                  break;
                case treat_name + "fontcolor":
                  if (value === 'default') {
                    return _current_style["font.color"] = _style["font.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["font.color"] = value;
                  }
                  break;
                case treat_name + "pencolor":
                  if (value === 'default') {
                    return _current_style["pen.color"] = _style["pen.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["pen.color"] = _this._getpenColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["pen.color"] = value;
                  }
                  break;
                case treat_name + "color":
                case treat_name + "brushcolor":
                  if (value === 'default') {
                    return _current_style["brush.color"] = _style["brush.color"];
                  } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                    return _current_style["brush.color"] = _this._getFontColor(values[0], values[1], values[2]);
                  } else {
                    return _current_style["brush.color"] = value;
                  }
              }
            };
            switch (name) {
              case 'name':
                is_text_style = true;
                _this._current_text_style["font.name"] = values.map(function(name) {
                  return '"' + name + '"';
                }).join(',');
                break;
              case 'height':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.height"] = _this._text_style["font.height"];
                } else if (/^[+-]/.test(value)) {
                  $size_checker = $('<span />').text('I').css({
                    position: 'absolute',
                    visibility: 'hidden',
                    'width': '1em',
                    'font-size': '1em',
                    padding: 0,
                    'line-height': '1em'
                  });
                  _this.insertPoint.append($size_checker);
                  size = $size_checker[0].clientHeight;
                  $size_checker.remove();
                  _this._current_text_style["font.height"] = (Number(size) + Number(value)) + 'px';
                } else if (!isNaN(value)) {
                  _this._current_text_style["font.height"] = value + 'px';
                } else {
                  _this._current_text_style["font.height"] = value;
                }
                break;
              case 'color':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.color"] = _this._text_style["font.color"];
                } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                  _this._current_text_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
                } else {
                  _this._current_text_style["font.color"] = value;
                }
                break;
              case 'shadowcolor':
                is_text_style = true;
                if (value === 'default') {
                  _this._current_text_style["font.shadowcolor"] = _this._text_style["font.shadowcolor"];
                } else if (value === 'none') {
                  _this._current_text_style["font.shadowcolor"] = void 0;
                } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                  _this._current_text_style["font.shadowcolor"] = _this._getFontColor(values[0], values[1], values[2]);
                } else {
                  _this._current_text_style["font.shadowcolor"] = value;
                }
                break;
              case 'bold':
                is_text_style = true;
                treat_bool('bold', value);
                break;
              case 'italic':
                is_text_style = true;
                treat_bool('italic', value);
                break;
              case 'strike':
                is_text_style = true;
                treat_bool('strike', value);
                break;
              case 'underline':
                is_text_style = true;
                treat_bool('underline', value);
                break;
              case 'default':
                is_text_style = true;
                _this._initializeCurrentStyle();
                break;
              case 'cursorstyle':
              case 'cursorfontcolor':
              case 'cursorpencolor':
              case 'cursorcolor':
              case 'cursorbrushcolor':
                treat_clickable_styles('cursor', name, value, values, _this._current_choice_style, _this._choice_style);
                break;
              case 'anchorstyle':
              case 'anchorfontcolor':
              case 'anchorpencolor':
              case 'anchorcolor':
              case 'anchorbrushcolor':
                treat_clickable_styles('anchor', name, value, values, _this._current_anchor_style, _this._anchor_style);
                break;
              case 'cursornotselectstyle':
              case 'cursornotselectfontcolor':
              case 'cursornotselectpencolor':
              case 'cursornotselectcolor':
              case 'cursornotselectbrushcolor':
                treat_clickable_styles('cursornotselect', name, value, values, _this._current_choice_notselect_style, _this._choice_notselect_style);
                break;
              case 'anchornotselectstyle':
              case 'anchornotselectfontcolor':
              case 'anchornotselectpencolor':
              case 'anchornotselectcolor':
              case 'anchornotselectbrushcolor':
                treat_clickable_styles('anchornotselect', name, value, values, _this._current_anchor_notselect_style, _this._anchor_notselect_style);
            }
            if (is_text_style) {
              $newimp = $('<span />');
              _this.insertPoint = $newimp.appendTo(_this.insertPoint);
              return _this.insertPoint.css(_this._blimpTextCSS(_this._current_text_style));
            }
          };
        })(this),
        location: location
      };
    };

    Scope.prototype._blimpTextCSS = function(styles) {
      var css, text_decoration;
      css = {};
      css["cursor"] = styles["cursor"];
      css["font-family"] = styles["font.name"];
      css["font-size"] = styles["font.height"];
      css["color"] = styles["font.color"];
      css["background"] = "none";
      css["outline"] = "none";
      css["border"] = "none";
      css["text-shadow"] = styles["font.shadowcolor"] ? "1px 1px 0 " + styles["font.shadowcolor"] : "none";
      css["font-weight"] = styles["font.bold"] ? "bold" : "normal";
      css["font-style"] = styles["font.italic"] ? "italic" : "normal";
      text_decoration = [];
      if (styles["font.strike"]) {
        text_decoration.push('line-through');
      }
      if (styles["font.underline"]) {
        text_decoration.push('underline');
      }
      css["text-decoration"] = text_decoration.length ? text_decoration.join(' ') : "none";
      css["line-height"] = "1.2em";
      return css;
    };

    Scope.prototype._blimpClickableTextCSS = function(styles, default_styles) {
      var background, border_bottom, color, outline;
      if (default_styles == null) {
        default_styles = {};
      }
      color = styles["font.color"] || default_styles["font.color"];
      outline = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      background = styles["brush.color"] || default_styles["brush.color"] || default_styles["font.color"];
      border_bottom = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      switch (styles["style"]) {
        case "square":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              "border-bottom": "none"
            }
          };
        case "underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              'border-bottom': border_bottom
            }
          };
        case "square+underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              'border-bottom': border_bottom
            }
          };
        case "none":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              "border-bottom": "none"
            }
          };
        default:
          return {
            base: {},
            over: {}
          };
      }
    };

    Scope.prototype._initializeCurrentStyle = function() {
      var name, ref, ref1, ref2, ref3, ref4, results, value;
      this._current_text_style = {};
      ref = this._text_style;
      for (name in ref) {
        value = ref[name];
        this._current_text_style[name] = value;
      }
      this._current_choice_style = {};
      ref1 = this._choice_style;
      for (name in ref1) {
        value = ref1[name];
        this._current_choice_style[name] = value;
      }
      this._current_choice_notselect_style = {};
      ref2 = this._choice_notselect_style;
      for (name in ref2) {
        value = ref2[name];
        this._current_choice_notselect_style[name] = value;
      }
      this._current_anchor_style = {};
      ref3 = this._anchor_style;
      for (name in ref3) {
        value = ref3[name];
        this._current_anchor_style[name] = value;
      }
      this._current_anchor_notselect_style = {};
      ref4 = this._anchor_notselect_style;
      results = [];
      for (name in ref4) {
        value = ref4[name];
        results.push(this._current_anchor_notselect_style[name] = value);
      }
      return results;
    };

    Scope.prototype._getFontColor = function(r, g, b, can_ignore) {
      var bc, gc, rc;
      rc = r != null ? r.replace(/%$/, '') : void 0;
      gc = g != null ? g.replace(/%$/, '') : void 0;
      bc = b != null ? b.replace(/%$/, '') : void 0;
      if ((isNaN(rc) || rc < 0) && (isNaN(gc) || gc < 0) && (isNaN(bc) || bc < 0)) {
        if (can_ignore) {

        } else {
          return "rgb(0,0,0)";
        }
      } else {
        return "rgb(" + r + "," + g + "," + b + ")";
      }
    };

    return Scope;

  })();

  Shell = (function() {
    function Shell(directory) {
      this.directory = directory;
      this.descript = null;
      this.surfaces = null;
    }

    Shell.prototype.load = function() {
      var hits, keys, prm, surfaces;
      if (!!this.directory["descript.txt"]) {
        this.descript = Util.parseDescript(Util.convert(this.directory["descript.txt"]));
      } else {
        this.descript = {};
        console.warn("descript.txt is not found");
      }
      keys = Object.keys(this.directory);
      hits = keys.filter(function(name) {
        return /surfaces\d*\.txt$/.test(name);
      });
      if (hits.length === 0) {
        console.warn("surfaces.txt is not found");
        surfaces = {
          "surfaces": {}
        };
      } else {
        surfaces = hits.reduce(((function(_this) {
          return function(obj, name) {
            var _srfs;
            _srfs = Shell.parseSurfaces(Util.convert(_this.directory[name]));
            return $.extend(true, obj, _srfs);
          };
        })(this)), {});
      }
      prm = Promise.resolve(surfaces);
      prm = prm.then(Shell.mergeSurfacesAndSurfacesFiles(this.directory));
      prm = prm.then(Shell.loadSurfaces(this.directory));
      prm = prm.then(Shell.loadElements(this.directory));
      prm = prm.then(Shell.createBases(this.directory));
      prm = prm.then((function(_this) {
        return function(surfaces) {
          _this.surfaces = surfaces;
          _this.directory = null;
          return _this;
        };
      })(this));
      prm = prm["catch"](function(err) {
        console.error(err);
        err.message && console.error(err.message);
        err.stack && console.error(err.stack);
        throw err;
      });
      return prm;
    };

    Shell.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var _surfaceId, hit, keys, ref, ref1, srfs, type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (Array.isArray((ref = this.surfaces.aliases) != null ? (ref1 = ref[type]) != null ? ref1[surfaceId] : void 0 : void 0)) {
        _surfaceId = SurfaceUtil.choice(this.surfaces.aliases[type][surfaceId]);
      } else {
        _surfaceId = surfaceId;
      }
      srfs = this.surfaces.surfaces;
      keys = Object.keys(srfs);
      hit = keys.filter(function(name) {
        return srfs[name].is === _surfaceId;
      })[0];
      if (!hit) {
        return null;
      }
      return new Surface(canvas, scopeId, hit, this.surfaces);
    };

    Shell.createBases = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var keys, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          keys.forEach(function(name) {
            var _baseSurface, _keys, baseSurface, elms, mapped, ref, sortedElms, srfutil;
            sortedElms = [];
            if (!!srfs[name].elements) {
              elms = srfs[name].elements;
              _keys = Object.keys(elms);
              mapped = _keys.map(function(key) {
                return {
                  is: elms[key].is,
                  x: elms[key].x,
                  y: elms[key].y,
                  canvas: elms[key].canvas,
                  type: elms[key].type
                };
              });
              sortedElms = mapped.sort(function(elmA, elmB) {
                if (elmA.is > elmB.is) {
                  return 1;
                } else {
                  return -1;
                }
              });
              delete srfs[name].elements;
            }
            baseSurface = srfs[name].baseSurface || ((ref = sortedElms[0]) != null ? ref.canvas : void 0);
            if (!baseSurface) {
              console.warn(name + " does not have base surface");
              return;
            }
            _baseSurface = SurfaceUtil.copy(baseSurface);
            srfutil = new SurfaceUtil(_baseSurface);
            srfutil.composeElements(sortedElms);
            return srfs[name].baseSurface = _baseSurface;
          });
          return resolve(surfaces);
        });
      };
    };

    Shell.loadElements = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, prm, promises, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          hits = keys.filter(function(name) {
            return !!srfs[name].elements;
          });
          promises = [];
          hits.forEach(function(srfName) {
            var elmKeys;
            elmKeys = Object.keys(srfs[srfName].elements);
            return elmKeys.forEach(function(elmName) {
              var _prm, elm, file, filename, path, type, x, y;
              elm = srfs[srfName].elements[elmName];
              type = elm.type, file = elm.file, x = elm.x, y = elm.y;
              keys = Object.keys(directory);
              path = keys.filter(function(path) {
                var a, b;
                a = path.toLowerCase();
                b = file.toLowerCase();
                if (a === b) {
                  return true;
                }
                if (a === (b + ".png").toLowerCase()) {
                  console.warn("element file " + b + " need '.png' extension");
                  return true;
                }
                return false;
              })[0];
              if (!path) {
                console.warn("element " + file + " is not found");
                elm.canvas = document.createElement("canvas");
                elm.canvas.width = 1;
                elm.canvas.height = 1;
                return;
              }
              if (!!directory[path]) {
                filename = path;
              } else if (!!directory[path + ".png"]) {
                filename = path + ".png";
              } else {
                filename = null;
              }
              if (!!filename) {
                _prm = Promise.resolve(filename);
                _prm = _prm.then(Shell.loadPNGAndPNA(directory));
                _prm = _prm.then(function(cnv) {
                  return elm.canvas = cnv;
                });
                _prm = _prm["catch"](reject);
                return promises.push(_prm);
              }
            });
          });
          prm = Promise.all(promises);
          prm = prm.then(function() {
            return resolve(surfaces);
          });
          prm = prm["catch"](reject);
          return prm;
        });
      };
    };

    Shell.loadSurfaces = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, prm, promises, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          hits = keys.filter(function(name) {
            return !!srfs[name].filename;
          });
          promises = hits.map(function(name) {
            var _prm;
            _prm = Promise.resolve(srfs[name].filename);
            _prm = _prm.then(Shell.loadPNGAndPNA(directory));
            _prm = _prm.then(function(cnv) {
              return srfs[name].baseSurface = cnv;
            });
            _prm = _prm["catch"](reject);
            return _prm;
          });
          prm = Promise.all(promises);
          prm = prm.then(function() {
            return resolve(surfaces);
          });
          prm = prm["catch"](reject);
          return prm;
        });
      };
    };

    Shell.loadPNGAndPNA = function(directory) {
      return function(filename) {
        return new Promise(function(resolve, reject) {
          var buffer, url;
          buffer = directory[filename];
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.loadImage(url, function(err, img) {
            var cnv, pnafilename;
            if (!!err) {
              URL.revokeObjectURL(url);
              return reject(err);
            } else {
              URL.revokeObjectURL(url);
              pnafilename = filename.replace(/\.png$/i, ".pna");
              cnv = SurfaceUtil.transImage(img);
              if (!directory[pnafilename]) {
                return resolve(SurfaceUtil.transImage(img));
              } else {
                buffer = directory[pnafilename];
                url = URL.createObjectURL(new Blob([buffer], {
                  type: "image/png"
                }));
                return SurfaceUtil.loadImage(url, function(err, pnaimg) {
                  var pnacnv;
                  if (!!err) {
                    URL.revokeObjectURL(url);
                    console.warn("cannot read pna file", filename, pnafilename, err);
                    return resolve(SurfaceUtil.transImage(img));
                  } else {
                    cnv = SurfaceUtil.copy(img);
                    pnacnv = SurfaceUtil.copy(pnaimg);
                    URL.revokeObjectURL(url);
                    return resolve(SurfaceUtil.pna(cnv, pnacnv));
                  }
                });
              }
            }
          });
        });
      };
    };

    Shell.mergeSurfacesAndSurfacesFiles = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, srfs, tuples;
          srfs = surfaces.surfaces;
          keys = Object.keys(directory);
          hits = keys.filter(function(filename) {
            return /^surface\d+\.png$/i.test(filename);
          });
          tuples = hits.map(function(filename) {
            return [Number((/^surface(\d+)\.png$/i.exec(filename) || ["", "-1"])[1]), filename];
          });
          tuples.forEach(function(arg) {
            var filename, n, name;
            n = arg[0], filename = arg[1];
            name = Object.keys(srfs).filter(function(name) {
              return srfs[name].is === n;
            })[0];
            name = name || "surface" + n;
            srfs[name] = srfs[name] || {
              is: n
            };
            srfs[name].filename = filename;
            srfs[name].baseSurface = document.createElement("canvas");
            srfs[name].baseSurface.width = 1;
            return srfs[name].baseSurface.height = 1;
          });
          return resolve(surfaces);
        });
      };
    };

    Shell.parseSurfaces = function(text) {
      var keys, srfs, surfaces;
      surfaces = SurfacesTxt2Yaml.txt_to_data(text, {
        compatible: 'ssp-lazy'
      });
      surfaces.surfaces = surfaces.surfaces || {};
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      surfaces.surfaces = keys.reduce((function(obj, name) {
        if (typeof srfs[name].is !== "undefined") {
          obj[name] = srfs[name];
        }
        if (Array.isArray(srfs[name].base)) {
          srfs[name].base.forEach(function(key) {
            return $.extend(true, srfs[name], srfs[key]);
          });
          delete srfs[name].base;
        }
        return obj;
      }), {});
      return surfaces;
    };

    return Shell;

  })();

  Surface = (function() {
    function Surface(element1, scopeId1, surfaceName, surfaces1) {
      var keys, srf;
      this.element = element1;
      this.scopeId = scopeId1;
      this.surfaceName = surfaceName;
      this.surfaces = surfaces1;
      srf = this.surfaces.surfaces[this.surfaceName];
      this.baseSurface = srf.baseSurface;
      this.regions = srf.regions || {};
      this.animations = srf.animations || {};
      this.bufferCanvas = SurfaceUtil.copy(this.baseSurface || document.createElement("canvas"));
      this.stopFlags = {};
      this.layers = {};
      this.destructed = false;
      this.talkCount = 0;
      this.talkCounts = {};
      this.isPointerEventsShimed = false;
      this.isRegionVisible = false;
      this.lastEventType = "";
      $(this.element).on("contextmenu", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseclick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("click", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseclick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("dblclick", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousedblclick", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mousedown", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousedown", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mousemove", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mousemove", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      $(this.element).on("mouseup", (function(_this) {
        return function(ev) {
          return _this.processMouseEvent(ev, "mouseup", function($ev) {
            return $(_this.element).trigger($ev);
          });
        };
      })(this));
      (function(_this) {
        return (function() {
          var tid, touchCount, touchStartTime;
          tid = 0;
          touchCount = 0;
          touchStartTime = 0;
          $(_this.element).on("touchmove", function(ev) {
            return _this.processMouseEvent(ev, "mousemove", function($ev) {
              return $(_this.element).trigger($ev);
            });
          });
          $(_this.element).on("touchend", function(ev) {
            _this.processMouseEvent(ev, "mouseup", function($ev) {
              return $(_this.element).trigger($ev);
            });
            _this.processMouseEvent(ev, "mouseclick", function($ev) {
              return $(_this.element).trigger($ev);
            });
            if (Date.now() - touchStartTime < 500 && touchCount % 2 === 0) {
              return _this.processMouseEvent(ev, "mousedblclick", function($ev) {
                return $(_this.element).trigger($ev);
              });
            }
          });
          return $(_this.element).on("touchstart", function(ev) {
            touchCount++;
            touchStartTime = Date.now();
            _this.processMouseEvent(ev, "mousedown", function($ev) {
              return $(_this.element).trigger($ev);
            });
            clearTimeout(tid);
            return tid = setTimeout((function() {
              return touchCount = 0;
            }), 500);
          });
        });
      })(this)();
      keys = Object.keys(this.animations);
      keys.forEach((function(_this) {
        return function(name) {
          var _is, animationId, interval, n, pattern, ref, tmp;
          ref = _this.animations[name], _is = ref.is, interval = ref.interval, pattern = ref.pattern;
          animationId = _is;
          interval = interval || "";
          tmp = interval.split(",");
          interval = tmp[0];
          n = Number(tmp.slice(1).join(","));
          switch (interval) {
            case "sometimes":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), 2);
            case "rarely":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), 4);
            case "random":
              return Surface.random((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), n);
            case "periodic":
              return Surface.periodic((function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              }), n);
            case "always":
              return Surface.always(function(callback) {
                if (!_this.destructed && !_this.stopFlags[animationId]) {
                  return _this.play(animationId, callback);
                }
              });
            case "runonce":
              return _this.play(animationId);
            case "never":
              break;
            case "bind":
              break;
            case "yen-e":
              break;
            case "talk":
              return _this.talkCounts[name] = n;
            default:
              if (/^bind(?:\+(\d+))/.test(interval)) {

              } else {
                return console.warn(_this.animations[name]);
              }
          }
        };
      })(this));
      this.render();
    }

    Surface.prototype.destructor = function() {
      SurfaceUtil.clear(this.element);
      $(this.element).off();
      this.destructed = true;
      this.layers = {};
    };

    Surface.prototype.yenE = function() {
      var hits, keys;
      keys = Object.keys(this.animations);
      hits = keys.filter((function(_this) {
        return function(name) {
          return _this.animations[name].interval === "yen-e" && _this.talkCount % _this.talkCounts[name] === 0;
        };
      })(this));
      hits.forEach((function(_this) {
        return function(name) {
          return _this.play(_this.animations[name].is);
        };
      })(this));
    };

    Surface.prototype.talk = function() {
      var hits, keys;
      this.talkCount++;
      keys = Object.keys(this.animations);
      hits = keys.filter((function(_this) {
        return function(name) {
          return /^talk/.test(_this.animations[name].interval) && _this.talkCount % _this.talkCounts[name] === 0;
        };
      })(this));
      hits.forEach((function(_this) {
        return function(name) {
          return _this.play(_this.animations[name].is);
        };
      })(this));
    };

    Surface.prototype.render = function() {
      var base, keys, mapped, patterns, sorted, srfs, util, util2;
      srfs = this.surfaces.surfaces;
      keys = Object.keys(this.layers);
      sorted = keys.sort(function(layerNumA, layerNumB) {
        if (Number(layerNumA) > Number(layerNumB)) {
          return 1;
        } else {
          return -1;
        }
      });
      mapped = sorted.map((function(_this) {
        return function(key) {
          return _this.layers[key];
        };
      })(this));
      patterns = mapped.reduce(((function(_this) {
        return function(arr, pat) {
          var hit, surface, type, x, y;
          surface = pat.surface, type = pat.type, x = pat.x, y = pat.y;
          if (surface === -1) {
            return arr;
          }
          keys = Object.keys(srfs);
          hit = keys.filter(function(key) {
            return srfs[key].is === surface;
          })[0];
          if (!hit) {
            return arr;
          }
          return arr.concat({
            type: type,
            x: x,
            y: y,
            canvas: srfs[hit].baseSurface
          });
        };
      })(this)), []);
      SurfaceUtil.clear(this.bufferCanvas);
      util = new SurfaceUtil(this.bufferCanvas);
      if (!!this.baseSurface || patterns.length > 0) {
        base = this.baseSurface || patterns[0].canvas;
        util.composeElements([
          {
            "type": "base",
            "canvas": base
          }
        ].concat(patterns));
        SurfaceUtil.clear(this.element);
        util2 = new SurfaceUtil(this.element);
        util2.init(this.bufferCanvas);
        if (this.isRegionVisible) {
          Object.keys(this.regions).forEach((function(_this) {
            return function(name) {
              util2.rendRegion(_this.regions[name]);
            };
          })(this));
        }
      }
    };

    Surface.prototype.play = function(animationId, callback) {
      var anim, hit, keys, lazyPromises, promise;
      if (callback == null) {
        callback = function() {};
      }
      keys = Object.keys(this.animations);
      hit = keys.filter((function(_this) {
        return function(name) {
          return _this.animations[name].is === animationId;
        };
      })(this))[0];
      if (!hit) {
        setTimeout(callback);
        return;
      }
      anim = this.animations[hit];
      lazyPromises = anim.patterns.map((function(_this) {
        return function(pattern) {
          return function() {
            return new Promise(function(resolve, reject) {
              var __, _animId, a, animation_ids, b, ref, surface, type, wait;
              surface = pattern.surface, wait = pattern.wait, type = pattern.type, animation_ids = pattern.animation_ids;
              if (/^start/.test(type)) {
                _animId = SurfaceUtil.choice(animation_ids);
                if (!!_this.animations[_animId]) {
                  _this.play(_this.animations[_animId].is, function() {
                    return resolve();
                  });
                  return;
                }
              }
              if (/^stop\,\d+/.test(type)) {
                _animId = SurfaceUtil.choice(animation_ids);
                if (!!_this.animations[_animId]) {
                  _this.play(_this.animations[_animId].is, function() {
                    return resolve();
                  });
                  return;
                }
              }
              if (/^alternativestart/.test(type)) {
                _animId = SurfaceUtil.choice(animation_ids);
                if (!!_this.animations[_animId]) {
                  _this.play(_this.animations[_animId].is, function() {
                    return resolve();
                  });
                  return;
                }
              }
              if (/^alternativestop/.test(type)) {
                _animId = SurfaceUtil.choice(animation_ids);
                if (!!_this.animations[_animId]) {
                  _this.play(_this.animations[_animId].is, function() {
                    return resolve();
                  });
                  return;
                }
              }
              _this.layers[anim.is] = pattern;
              _this.render();
              ref = /(\d+)(?:\-(\d+))?/.exec(wait) || ["", "0"], __ = ref[0], a = ref[1], b = ref[2];
              if (!!b) {
                wait = _.random(Number(a), Number(b));
              }
              return setTimeout((function() {
                if (_this.destructed) {
                  return reject();
                } else {
                  return resolve();
                }
              }), wait);
            });
          };
        };
      })(this));
      promise = lazyPromises.reduce((function(proA, proB) {
        return proA.then(proB);
      }), Promise.resolve());
      promise.then((function(_this) {
        return function() {
          return setTimeout(callback);
        };
      })(this))["catch"](function(err) {
        if (!!err) {
          return console.error(err.stack);
        }
      });
    };

    Surface.prototype.stop = function(animationId) {
      this.stopFlags[animationId] = true;
    };

    Surface.prototype.bind = function(animationId) {
      var anim, animIds, hit, interval, keys, pattern;
      keys = Object.keys(this.animations);
      hit = keys.filter((function(_this) {
        return function(name) {
          return _this.animations[name].is === animationId;
        };
      })(this))[0];
      if (!hit) {
        return;
      }
      anim = this.animations[hit];
      if (anim.patterns.length === 0) {
        return;
      }
      interval = anim.interval;
      pattern = anim.patterns[anim.patterns.length - 1];
      this.layers[anim.is] = pattern;
      this.render();
      if (/^bind(?:\+(\d+))/.test(interval)) {
        animIds = interval.split("+").slice(1);
        animIds.forEach((function(_this) {
          return function(animId) {
            return _this.play(animId, function() {});
          };
        })(this));
      }
    };

    Surface.prototype.unbind = function(animationId) {
      delete this.layers[animationId];
    };

    Surface.prototype.processMouseEvent = function(ev, eventName, callback) {
      var _ev, detail, elm, hit, keys, left, offsetX, offsetY, pageX, pageY, ref, ref1, sorted, top, touches;
      $(ev.target).css({
        "cursor": "default"
      });
      if (this.isPointerEventsShimed && ev.type === this.lastEventType) {
        this.lastEventType = "";
        this.isPointerEventsShimed = false;
        ev.stopPropagation();
        ev.preventDefault();
        return;
      }
      if (/^touch/.test(ev.type)) {
        ref = ev.changedTouches[0], pageX = ref.pageX, pageY = ref.pageY;
      } else {
        pageX = ev.pageX, pageY = ev.pageY;
      }
      ref1 = $(ev.target).offset(), left = ref1.left, top = ref1.top;
      offsetX = pageX - left;
      offsetY = pageY - top;
      if (Surface.isHit(ev.target, offsetX, offsetY)) {
        ev.preventDefault();
        detail = {
          "type": eventName,
          "offsetX": offsetX | 0,
          "offsetY": offsetY | 0,
          "wheel": 0,
          "scope": this.scopeId,
          "region": "",
          "button": (ev.button === 2 ? 1 : 0)
        };
        keys = Object.keys(this.regions);
        sorted = keys.sort(function(a, b) {
          if (a.is > b.is) {
            return 1;
          } else {
            return -1;
          }
        });
        hit = sorted.filter((function(_this) {
          return function(name) {
            var bottom, center_x, center_y, coordinates, deg, height, ptC, radius, ref2, right, tuples, type, width;
            ref2 = _this.regions[name], type = ref2.type, name = ref2.name, left = ref2.left, top = ref2.top, right = ref2.right, bottom = ref2.bottom, coordinates = ref2.coordinates, radius = ref2.radius, center_x = ref2.center_x, center_y = ref2.center_y;
            switch (type) {
              case "rect":
                return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
              case "ellipse":
                width = Math.abs(right - left);
                height = Math.abs(bottom - top);
                return Math.pow((offsetX - (left + width / 2)) / (width / 2), 2) + Math.pow((offsetY - (top + height / 2)) / (height / 2), 2) < 1;
              case "circle":
                return Math.pow((offsetX - center_x) / radius, 2) + Math.pow((offsetY - center_y) / radius, 2) < 1;
              case "polygon":
                ptC = {
                  x: offsetX,
                  y: offsetY
                };
                tuples = coordinates.reduce((function(arr, arg, i) {
                  var x, y;
                  x = arg.x, y = arg.y;
                  arr.push([coordinates[i], (!!coordinates[i + 1] ? coordinates[i + 1] : coordinates[0])]);
                  return arr;
                }), []);
                deg = tuples.reduce((function(sum, arg) {
                  var absA, absB, dotP, ptA, ptB, rad, vctA, vctB;
                  ptA = arg[0], ptB = arg[1];
                  vctA = [ptA.x - ptC.x, ptA.y - ptC.y];
                  vctB = [ptB.x - ptC.x, ptB.y - ptC.y];
                  dotP = vctA[0] * vctB[0] + vctA[1] * vctB[1];
                  absA = Math.sqrt(vctA.map(function(a) {
                    return Math.pow(a, 2);
                  }).reduce(function(a, b) {
                    return a + b;
                  }));
                  absB = Math.sqrt(vctB.map(function(a) {
                    return Math.pow(a, 2);
                  }).reduce(function(a, b) {
                    return a + b;
                  }));
                  rad = Math.acos(dotP / (absA * absB));
                  return sum + rad;
                }), 0);
                return deg / (2 * Math.PI) >= 1;
              default:
                console.warn(_this.surfaceName, name, _this.regions[name]);
                return false;
            }
          };
        })(this))[0];
        if (!!hit) {
          if (/^touch/.test(ev.type)) {
            ev.stopPropagation();
          }
          detail["region"] = this.regions[hit].name;
          $(ev.target).css({
            "cursor": "pointer"
          });
        }
        callback($.Event('IkagakaDOMEvent', {
          detail: detail,
          bubbles: true
        }));
      } else {
        elm = Surface.isHitBubble(ev.target, ev.pageX, ev.pageY);
        if (!elm) {
          return;
        }
        if (/^mouse/.test(ev.type)) {
          this.isPointerEventsShimed = true;
          this.lastEventType = ev.type;
          ev.preventDefault();
          ev.stopPropagation();
          _ev = document.createEvent("MouseEvent");
          if (typeof _ev.initMouseEvent === "function") {
            _ev.initMouseEvent(ev.type, ev.bubbles, ev.cancelable, ev.view, ev.detail, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, ev.button, ev.relatedTarget);
          }
          elm.dispatchEvent(_ev);
        } else if (/^touch/.test(ev.type) && !!document.createTouchList) {
          this.isPointerEventsShimed = true;
          this.lastEventType = ev.type;
          ev.preventDefault();
          ev.stopPropagation();
          touches = document.createTouchList();
          touches[0] = document.createTouch(document.body, ev.target, 0, ev.pageX, ev.pageY, ev.screenX, ev.screenY, ev.clientX, ev.clientY, 1, 1, 0, 1.0);
          _ev = document.createEvent("TouchEvent");
          _ev.initTouchEvent(touches, touches, touches, ev.type, ev.view, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey);
          elm.dispatchEvent(_ev);
        }
      }
    };

    Surface.random = function(callback, n) {
      var ms;
      ms = 1;
      while (Math.round(Math.random() * 1000) > 1000 / n) {
        ms++;
      }
      setTimeout((function() {
        return callback(function() {
          return Surface.random(callback, n);
        });
      }), ms * 1000);
    };

    Surface.periodic = function(callback, n) {
      setTimeout((function() {
        return callback(function() {
          return Surface.periodic(callback, n);
        });
      }), n * 1000);
    };

    Surface.always = function(callback) {
      callback(function() {
        return Surface.always(callback);
      });
    };

    Surface.isHit = function(canvas, x, y) {
      var ctx, data, imgdata;
      ctx = canvas.getContext("2d");
      imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
      data = imgdata.data;
      return data[data.length - 1] !== 0;
    };

    Surface.isHitBubble = function(element, pageX, pageY) {
      var _elm, elm, left, ref, top;
      $(element).hide();
      elm = document.elementFromPoint(pageX, pageY);
      if (!elm) {
        $(element).show();
        return elm;
      }
      if (!(elm instanceof HTMLCanvasElement)) {
        $(element).show();
        return elm;
      }
      ref = $(elm).offset(), top = ref.top, left = ref.left;
      if (Surface.isHit(elm, pageX - left, pageY - top)) {
        $(element).show();
        return elm;
      }
      _elm = Surface.isHitBubble(elm, pageX, pageY);
      $(element).show();
      return _elm;
    };

    return Surface;

  })();

  SurfaceUtil = (function() {
    function SurfaceUtil(cnv1) {
      this.cnv = cnv1;
      this.ctx = this.cnv.getContext("2d");
    }

    SurfaceUtil.prototype.composeElements = function(elements) {
      var canvas, copyed, offsetX, offsetY, ref, type, x, y;
      if (elements.length === 0) {
        return;
      }
      ref = elements[0], canvas = ref.canvas, type = ref.type, x = ref.x, y = ref.y;
      offsetX = offsetY = 0;
      switch (type) {
        case "base":
          this.base(canvas, offsetX, offsetY);
          break;
        case "overlay":
          this.overlay(canvas, offsetX + x, offsetY + y);
          break;
        case "overlayfast":
          this.overlayfast(canvas, offsetX + x, offsetY + y);
          break;
        case "replace":
          this.replace(canvas, offsetX + x, offsetY + y);
          break;
        case "add":
          this.overlayfast(canvas, offsetX + x, offsetY + y);
          break;
        case "bind":
          this.overlayfast(canvas, offsetX + x, offsetY + y);
          break;
        case "interpolate":
          this.interpolate(canvas, offsetX + x, offsetY + y);
          break;
        case "move":
          offsetX = x;
          offsetY = y;
          copyed = SurfaceUtil.copy(this.cnv);
          this.base(copyed, offsetX, offsetY);
          break;
        default:
          console.error(elements[0]);
      }
      this.composeElements(elements.slice(1));
    };

    SurfaceUtil.prototype.base = function(part, x, y) {
      SurfaceUtil.clear(this.cnv);
      this.init(part, x, y);
    };

    SurfaceUtil.prototype.overlay = function(part, x, y) {
      this.ctx.globalCompositeOperation = "source-over";
      if (this.cnv.width < part.width || this.cnv.height < part.height) {
        this.base(part, x, y);
      } else {
        this.ctx.drawImage(part, x, y);
      }
    };

    SurfaceUtil.prototype.overlayfast = function(part, x, y) {
      this.ctx.globalCompositeOperation = "source-over";
      this.ctx.drawImage(part, x, y);
    };

    SurfaceUtil.prototype.interpolate = function(part, x, y) {
      this.ctx.globalCompositeOperation = "destination-over";
      this.ctx.drawImage(part, x, y);
    };

    SurfaceUtil.prototype.replace = function(part, x, y) {
      this.ctx.clearRect(x, y, part.width, part.height);
      this.overlayfast(part, x, y);
    };

    SurfaceUtil.prototype.init = function(cnv, x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      this.cnv.width = cnv.width;
      this.cnv.height = cnv.height;
      this.overlayfast(cnv, x, y);
    };

    SurfaceUtil.prototype.rendRegion = function(arg) {
      var bottom, center_x, center_y, coordinates, left, name, radius, right, top, type;
      type = arg.type, name = arg.name, left = arg.left, top = arg.top, right = arg.right, bottom = arg.bottom, coordinates = arg.coordinates, radius = arg.radius, center_x = arg.center_x, center_y = arg.center_y;
      this.ctx.strokeStyle = "#00FF00";
      switch (type) {
        case "rect":
          this.ctx.rect(left, top, right - left, bottom - top);
          break;
        case "ellipse":
          this.ctx.rect(left, top, right - left, bottom - top);
          break;
        case "circle":
          this.ctx.rect(left, top, right - left, bottom - top);
          break;
        case "polygon":
          this.ctx.rect(left, top, right - left, bottom - top);
      }
      this.ctx.stroke();
      this.ctx.font = "35px";
      this.ctx.strokeStyle = "white";
      this.ctx.strokeText(type + ":" + name, left, top);
      this.ctx.fillStyle = "black";
      this.ctx.fillText(type + ":" + name, left, top);
    };

    SurfaceUtil.pna = function(cnvA, cnvB) {
      var ctxA, ctxB, dataA, dataB, i, imgdataA, imgdataB;
      ctxA = cnvA.getContext("2d");
      ctxB = cnvB.getContext("2d");
      imgdataA = ctxA.getImageData(0, 0, cnvA.width, cnvA.height);
      imgdataB = ctxB.getImageData(0, 0, cnvB.width, cnvB.height);
      dataA = imgdataA.data;
      dataB = imgdataB.data;
      i = 0;
      while (i < dataA.length) {
        dataA[i + 3] = dataB[i];
        i += 4;
      }
      ctxA.putImageData(imgdataA, 0, 0);
      return cnvA;
    };

    SurfaceUtil.choice = function(ary) {
      return ary[Math.round(Math.random() * (ary.length - 1))];
    };

    SurfaceUtil.clear = function(cnv) {
      cnv.width = cnv.width;
    };

    SurfaceUtil.copy = function(cnv) {
      var copy, ctx;
      copy = document.createElement("canvas");
      ctx = copy.getContext("2d");
      copy.width = cnv.width;
      copy.height = cnv.height;
      ctx.drawImage(cnv, 0, 0);
      return copy;
    };

    SurfaceUtil.transImage = function(img) {
      var a, b, cnv, ctx, data, g, i, imgdata, r;
      cnv = SurfaceUtil.copy(img);
      ctx = cnv.getContext("2d");
      imgdata = ctx.getImageData(0, 0, img.width, img.height);
      data = imgdata.data;
      r = data[0], g = data[1], b = data[2], a = data[3];
      i = 0;
      if (a !== 0) {
        while (i < data.length) {
          if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
            data[i + 3] = 0;
          }
          i += 4;
        }
      }
      ctx.putImageData(imgdata, 0, 0);
      return cnv;
    };

    SurfaceUtil.loadImage = function(url, callback) {
      var img;
      img = new Image;
      img.src = url;
      img.addEventListener("load", function() {
        return callback(null, img);
      });
      img.addEventListener("error", function(ev) {
        console.error(ev);
        return callback(ev.error, null);
      });
    };

    return SurfaceUtil;

  })();

  cuttlebone = {};

  cuttlebone["NamedManager"] = NamedManager;

  cuttlebone["Named"] = Named;

  cuttlebone["Scope"] = Scope;

  cuttlebone["Shell"] = Shell;

  cuttlebone["Surface"] = Surface;

  cuttlebone["SurfaceUtil"] = SurfaceUtil;

  cuttlebone["Balloon"] = Balloon;

  cuttlebone["BalloonSurface"] = BalloonSurface;

  global["cuttlebone"] = cuttlebone;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = cuttlebone;
  }

}).call(this);

//# sourceMappingURL=cuttlebone.js.map
