// Generated by CoffeeScript 1.8.0
(function() {
  var Miyo, ShioriJK, chai, chaiAsPromised, expect, sinon;

  if (typeof require !== "undefined" && require !== null) {
    chai = require('chai');
  } else {
    chai = this.chai;
  }

  chai.should();

  expect = chai.expect;

  if (typeof require !== "undefined" && require !== null) {
    chaiAsPromised = require('chai-as-promised');
  } else {
    chaiAsPromised = this.chaiAsPromised;
  }

  chai.use(chaiAsPromised);

  if (typeof require !== "undefined" && require !== null) {
    sinon = require('sinon');
    ShioriJK = require('shiorijk');
    Miyo = require('../lib/miyo.js');
  } else {
    sinon = this.sinon;
    ShioriJK = this.ShioriJK;
    Miyo = this.Miyo;
  }

  describe('build_response', function() {
    var ms;
    ms = null;
    beforeEach(function() {
      return ms = new Miyo();
    });
    return it('should build response', function() {
      var res;
      res = ms.build_response();
      return res.should.be.deep.equal(new ShioriJK.Message.Response());
    });
  });

  describe('make_value', function() {
    var ms;
    ms = null;
    beforeEach(function() {
      ms = new Miyo();
      return ms.default_response_headers.Charset = 'UTF-8';
    });
    it('should make 204 on empty value', function() {
      var res;
      res = ms.make_value('');
      res.status_line.code.should.be.equal(204);
      expect(res.headers.get('Value')).be.undefined;
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    it('should make 204 on null value', function() {
      var res;
      res = ms.make_value(null);
      res.status_line.code.should.be.equal(204);
      expect(res.headers.get('Value')).be.undefined;
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    it('should make 204 on undefined value', function() {
      var res;
      res = ms.make_value();
      res.status_line.code.should.be.equal(204);
      expect(res.headers.get('Value')).be.undefined;
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    it('should make 200 on normal value', function() {
      var res, value, value_res;
      value = '\\h\\s[0]\\e';
      value_res = value.replace(/[\r\n]/g, '');
      res = ms.make_value(value);
      res.status_line.code.should.be.equal(200);
      expect(res.headers.get('Value')).be.equal(value_res);
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    return it('should make 200 and remove line feeds on normal value', function() {
      var res, value, value_res;
      value = '\\h\\s[0]\n\r\\e\r\n';
      value_res = value.replace(/[\r\n]/g, '');
      res = ms.make_value(value);
      res.status_line.code.should.be.equal(200);
      expect(res.headers.get('Value')).be.equal(value_res);
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
  });

  describe('make_bad_request', function() {
    var ms;
    ms = null;
    beforeEach(function() {
      ms = new Miyo();
      return ms.default_response_headers.Charset = 'UTF-8';
    });
    return it('should make 400', function() {
      var res;
      res = ms.make_bad_request();
      res.status_line.code.should.be.equal(400);
      expect(res.headers.get('Value')).be.undefined;
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
  });

  describe('make_internal_server_error', function() {
    var ms;
    ms = null;
    beforeEach(function() {
      ms = new Miyo();
      return ms.default_response_headers.Charset = 'UTF-8';
    });
    it('should make 500', function() {
      var error, res;
      error = null;
      res = ms.make_internal_server_error(error);
      res.status_line.code.should.be.equal(500);
      expect(res.headers.get('Value')).be.undefined;
      expect(res.headers.get('X-Miyo-Error')).be.undefined;
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    it('should make 500 with error header', function() {
      var error, error_res, res;
      error = 'this is the error\0';
      error_res = ("" + error).replace(/\r/g, '\\r').replace(/\n/g, '\\n');
      res = ms.make_internal_server_error(error);
      res.status_line.code.should.be.equal(500);
      expect(res.headers.get('Value')).be.undefined;
      expect(res.headers.get('X-Miyo-Error')).be.equal(error_res);
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
    return it('should make 500 with error header that has no raw line feeds', function() {
      var error, error_res, res;
      error = 'error\nerror\r\n';
      error_res = ("" + error).replace(/\r/g, '\\r').replace(/\n/g, '\\n');
      res = ms.make_internal_server_error(error);
      res.status_line.code.should.be.equal(500);
      expect(res.headers.get('Value')).be.undefined;
      expect(res.headers.get('X-Miyo-Error')).be.equal(error_res);
      return expect(res.headers.get('Charset')).be.equal('UTF-8');
    });
  });

  describe('call_not_found', function() {
    var ms;
    ms = null;
    beforeEach(function() {
      ms = new Miyo();
      return ms.default_response_headers.Charset = 'UTF-8';
    });
    return it('should return 400', function() {
      return ms.call_not_found().then(function(res) {
        return res.status_line.code.should.be.equal(400);
      }).should.eventually.be.fulfilled;
    });
  });

  describe('call_value', function() {
    var id, ms, request, stash, value;
    ms = null;
    request = null;
    id = null;
    value = null;
    stash = null;
    beforeEach(function() {
      ms = new Miyo();
      request = new ShioriJK.Message.Request();
      id = 'OnTest';
      value = '\\h\\s[0]';
      return stash = 'stash';
    });
    it('should pass value to value_filters', function() {
      ms.filters.test_value_filter = {
        type: 'value-value',
        filter: function(value, request, id, stash) {
          return value + '\\e';
        }
      };
      ms.value_filters.push('test_value_filter');
      return ms.call_value(value, request, id, stash).should.eventually.be.equal(value + '\\e');
    });
    it('should pass exact arguments to filters', function() {
      ms.filters.test_value_filter = {
        type: 'value-value',
        filter: function(value, request, id, stash) {
          return request + id + value + stash + '\\e';
        }
      };
      ms.value_filters.push('test_value_filter');
      return ms.call_value(value, request, id, stash).should.eventually.be.equal(request + id + value + stash + '\\e');
    });
    return it('should throw on filter not found', function() {
      ms.value_filters.push('test_value_filter');
      return ms.call_value(value, request, id, stash).should.rejectedWith(/not found/);
    });
  });

  describe('call_filters', function() {
    var id, ms, request, stash, test;
    ms = null;
    test = null;
    request = null;
    id = null;
    stash = null;
    beforeEach(function() {
      ms = new Miyo();
      test = null;
      ms.filters.no_type = {
        filter: function() {}
      };
      ms.filters.wrong_type = {
        type: 'wrong',
        filter: function() {}
      };
      ms.filters.no_function = {
        type: 'any-value'
      };
      ms.prop = 0;
      ms.filters.this_prop_inc = {
        type: 'through',
        filter: function(argument, request, id, stash) {
          this.prop++;
          return argument;
        }
      };
      ms.filters.value_plus_end = {
        type: 'value-value',
        filter: function(value, request, id, stash) {
          return value + 'end';
        }
      };
      ms.filters.arg_to_value = {
        type: 'data-value',
        filter: function(argument, request, id, stash) {
          return argument.arg_to_value;
        }
      };
      ms.filters.arg_to_argument = {
        type: 'data-data',
        filter: function(argument, request, id, stash) {
          return argument.arg_to_argument;
        }
      };
      ms.filters.arg_or_value_to_value = {
        type: 'any-value',
        filter: function(argument, request, id, stash) {
          if ('string' === typeof argument) {
            return argument;
          } else {
            return argument.arg_or_value_to_value;
          }
        }
      };
      ms.filters.set_stash = {
        type: 'through',
        filter: function(argument, request, id, stash) {
          var name, value, _ref, _results;
          _ref = argument.set_stash;
          _results = [];
          for (name in _ref) {
            value = _ref[name];
            _results.push(stash[name] = value);
          }
          return _results;
        }
      };
      ms.filters.get_stash = {
        type: 'any-value',
        filter: function(argument, request, id, stash) {
          return stash;
        }
      };
      sinon.spy(ms.filters.arg_or_value_to_value, 'filter');
      request = new ShioriJK.Message.Request();
      id = 'OnTest';
      return stash = 'stash';
    });
    it('should throw on filter not found', function() {
      var entry;
      entry = {
        filters: ['test_filter_not_exists']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/not found/);
    });
    it('should throw on wrong(no) filter type', function() {
      var entry;
      entry = {
        filters: ['no_type']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/invalid filter type/);
    });
    it('should throw on wrong filter type', function() {
      var entry;
      entry = {
        filters: ['wrong_type']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/invalid filter type/);
    });
    it('should throw on empty filter function', function() {
      var entry;
      entry = {
        filters: ['no_function']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/function is undefined/);
    });
    it('should check filters types', function() {
      var entry;
      entry = {
        filters: ['this_prop_inc', 'arg_to_argument', 'arg_to_value', 'this_prop_inc', 'value_plus_end', 'arg_or_value_to_value', 'this_prop_inc', 'this_prop_inc'],
        argument: {
          arg_to_argument: {
            arg_to_value: 'ret'
          }
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.fulfilled;
    });
    it('should check filters type [any-value]', function() {
      var entry;
      entry = {
        filters: ['arg_to_argument', 'arg_or_value_to_value'],
        argument: {
          arg_to_argument: {
            arg_or_value_to_value: 'ret'
          }
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.fulfilled;
    });
    it('should check filters type [any-value] 2', function() {
      var entry;
      entry = {
        filters: ['arg_to_value', 'arg_or_value_to_value'],
        argument: {
          arg_to_value: 'ret'
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.fulfilled;
    });
    it('should check filters type [through]', function() {
      var entry;
      entry = {
        filters: ['arg_to_argument', 'this_prop_inc', 'arg_or_value_to_value'],
        argument: {
          arg_to_argument: {
            arg_or_value_to_value: 'ret'
          }
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.fulfilled;
    });
    it('should check filters type [through] 2', function() {
      var entry;
      entry = {
        filters: ['arg_to_value', 'this_prop_inc', 'arg_or_value_to_value'],
        argument: {
          arg_to_value: 'ret'
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.fulfilled;
    });
    it('should throw with filters type inconsistency', function() {
      var entry;
      entry = {
        filters: ['this_prop_inc']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/inconsistent with final/);
    });
    it('should throw with filters type inconsistency 2', function() {
      var entry;
      entry = {
        filters: ['arg_to_argument'],
        argument: {
          arg_to_argument: 'dummy'
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/inconsistent with final/);
    });
    it('should throw with filters type inconsistency 3', function() {
      var entry;
      entry = {
        filters: ['value_plus_end']
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/inconsistent with previous/);
    });
    it('should throw with filters type inconsistency 4', function() {
      var entry;
      entry = {
        filters: ['arg_to_argument', 'value_plus_end'],
        argument: {
          arg_to_argument: 'dummy'
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.rejectedWith(/inconsistent with previous/);
    });
    it('should pass argument and filter-return-value to filters sequentially', function() {
      var entry;
      entry = {
        filters: ['arg_to_argument', 'arg_to_value'],
        argument: {
          arg_to_argument: {
            arg_to_value: 'ret'
          }
        }
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.be.deep.equal('ret');
    });
    it('should treat non-array filters property', function() {
      var entry;
      entry = {
        filters: 'arg_or_value_to_value',
        argument: 'ret'
      };
      return ms.call_filters(entry, request, id, stash).should.eventually.be.deep.equal('ret');
    });
    it('should pass exact arguments to filters', function() {
      var entry;
      entry = {
        filters: ['arg_or_value_to_value'],
        argument: {
          arg_or_value_to_value: 'ret'
        }
      };
      return ms.call_filters(entry, request, id, stash).then(function() {
        ms.filters.arg_or_value_to_value.filter.calledOnce.should.be["true"];
        return ms.filters.arg_or_value_to_value.filter.calledWithExactly(entry.argument, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    it('should initialize stash as hash', function() {
      var entry;
      stash = null;
      entry = {
        filters: ['get_stash']
      };
      return ms.call_filters(entry, request, id, stash).then(function(return_stash) {
        return return_stash.should.be.deep.equal({});
      }).should.eventually.be.fulfilled;
    });
    return it('should pass stash', function() {
      var entry;
      stash = null;
      entry = {
        filters: ['set_stash', 'get_stash'],
        argument: {
          set_stash: {
            foo: 'foo'
          }
        }
      };
      return ms.call_filters(entry, request, id, stash).then(function(return_stash) {
        return return_stash.should.be.deep.equal({
          foo: 'foo'
        });
      }).should.eventually.be.fulfilled;
    });
  });

  describe('call_list', function() {
    var call_entry_spy, id, ms, random_stub, request, stash;
    ms = null;
    request = null;
    id = null;
    stash = null;
    random_stub = null;
    call_entry_spy = null;
    beforeEach(function() {
      ms = new Miyo();
      random_stub = sinon.stub(Math, 'random');
      call_entry_spy = sinon.spy(ms, 'call_entry');
      request = new ShioriJK.Message.Request();
      id = 'OnTest';
      return stash = 'stash';
    });
    afterEach(function() {
      return random_stub.restore();
    });
    it('should call call_entry on simple entry', function() {
      var entry;
      random_stub.returns(0);
      entry = ['\\h\\s[0]\\e', '\\h\\s[1]\\e'];
      return ms.call_list(entry, request, id, stash).then(function(res) {
        res.should.be.equal(entry[0]);
        call_entry_spy.callCount.should.be.equal(1);
        return call_entry_spy.firstCall.calledWithExactly(entry[0], request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    return it('should call call_entry recursively on nested entry', function() {
      var entry;
      random_stub.returns(0);
      entry = [['\\h\\s[0]\\e', '\\h\\s[1]\\e'], '\\h\\s[2]\\e', '\\h\\s[3]\\e'];
      return ms.call_list(entry, request, id, stash).then(function(res) {
        res.should.be.equal(entry[0][0]);
        call_entry_spy.callCount.should.be.equal(2);
        call_entry_spy.firstCall.calledWithExactly(entry[0], request, id, stash).should.be["true"];
        return call_entry_spy.lastCall.calledWithExactly(entry[0][0], request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
  });

  describe('call_entry', function() {
    var id, ms, request, stash;
    ms = null;
    request = null;
    id = null;
    stash = null;
    beforeEach(function() {
      ms = new Miyo();
      request = new ShioriJK.Message.Request();
      id = 'OnTest';
      return stash = 'stash';
    });
    it('should pass value entry to call_value', function() {
      var entry, s;
      entry = '\\h\\s[0]\\e';
      s = sinon.spy(ms, 'call_value');
      return ms.call_entry(entry, request, id, stash).then(function() {
        s.calledOnce.should.be["true"];
        return s.firstCall.calledWithExactly(entry, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    it('should pass filter entry to call_filters', function() {
      var entry, s;
      ms.filters.test_filter = {
        type: 'data-value',
        filter: function(argument, request, id, stash) {
          return argument;
        }
      };
      entry = {
        filters: ['test_filter'],
        argument: {
          test_filter: 'test'
        }
      };
      s = sinon.spy(ms, 'call_filters');
      return ms.call_entry(entry, request, id, stash).then(function() {
        s.calledOnce.should.be["true"];
        return s.firstCall.calledWithExactly(entry, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    it('should pass list entry to call_list', function() {
      var entry, random_stub, s;
      random_stub = sinon.stub(Math, 'random');
      random_stub.returns(0.9);
      entry = [['\\h\\s[0]\\e', '\\h\\s[1]\\e'], '\\h\\s[2]\\e', '\\h\\s[3]\\e'];
      s = sinon.spy(ms, 'call_list');
      return ms.call_entry(entry, request, id, stash).then(function() {
        s.calledOnce.should.be["true"];
        s.firstCall.calledWithExactly(entry, request, id, stash).should.be["true"];
        return random_stub.restore();
      }).should.eventually.be.fulfilled;
    });
    return it('should pass invalid entry to call_not_found', function() {
      var entry, s;
      entry = undefined;
      s = sinon.spy(ms, 'call_not_found');
      return ms.call_entry(entry, request, id, stash).then(function() {
        s.calledOnce.should.be["true"];
        return s.firstCall.calledWithExactly(entry, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
  });

  describe('call_id', function() {
    var call_entry_spy, dictionary, ms, stash;
    ms = null;
    stash = null;
    call_entry_spy = null;
    dictionary = {
      _load: 'load',
      OnTest: '\\h\\s[0]\\e'
    };
    beforeEach(function() {
      ms = new Miyo(dictionary);
      return call_entry_spy = sinon.spy(ms, 'call_entry');
    });
    it('should not call_id on undefined entry with null request (load, unload)', function() {
      var id, request;
      id = '_unload';
      request = null;
      return ms.call_id(id, request, stash).then(function(res) {
        call_entry_spy.callCount.should.be.equal(0);
        return expect(res).be.undefined;
      }).should.eventually.be.fulfilled;
    });
    it('should call_id on defined entry with null request (load, unload)', function() {
      var id, request;
      id = '_load';
      request = null;
      return ms.call_id(id, request, stash).then(function() {
        call_entry_spy.calledOnce.should.be["true"];
        return call_entry_spy.firstCall.calledWithExactly(dictionary._load, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    it('should call_id on undefined entry with normal request (request)', function() {
      var id, request;
      id = 'onTestTest';
      request = new ShioriJK.Message.Request();
      return ms.call_id(id, request, stash).then(function() {
        call_entry_spy.calledOnce.should.be["true"];
        return call_entry_spy.firstCall.calledWithExactly(undefined, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
    return it('should call_id on defined entry with normal request (request)', function() {
      var id, request;
      id = 'OnTest';
      request = new ShioriJK.Message.Request();
      return ms.call_id(id, request, stash).then(function() {
        call_entry_spy.calledOnce.should.be["true"];
        return call_entry_spy.firstCall.calledWithExactly(dictionary.OnTest, request, id, stash).should.be["true"];
      }).should.eventually.be.fulfilled;
    });
  });

  describe('load', function() {
    var call_id_spy, ms;
    ms = null;
    call_id_spy = null;
    beforeEach(function() {
      ms = new Miyo({});
      return call_id_spy = sinon.spy(ms, 'call_id');
    });
    return it('should call_id("_load", null) and store shiori_dll_directory', function() {
      var directory;
      directory = '/';
      return ms.load(directory).then(function() {
        call_id_spy.calledOnce.should.be["true"];
        call_id_spy.firstCall.calledWithExactly('_load', null).should.be["true"];
        return ms.shiori_dll_directory.should.be.equal(directory);
      }).should.eventually.be.fulfilled;
    });
  });

  describe('unload', function() {
    var call_id_spy, exit_stub, ms;
    ms = null;
    exit_stub = null;
    call_id_spy = null;
    beforeEach(function() {
      ms = new Miyo({});
      if (typeof process !== "undefined" && process !== null) {
        exit_stub = sinon.stub(process, 'exit');
      }
      return call_id_spy = sinon.spy(ms, 'call_id');
    });
    afterEach(function() {
      if (typeof process !== "undefined" && process !== null) {
        return exit_stub.restore();
      }
    });
    return it('should call_id("_unload", null) and process.exit()', function() {
      return ms.unload().then(function() {
        call_id_spy.calledOnce.should.be["true"];
        call_id_spy.firstCall.calledWithExactly('_unload', null).should.be["true"];
        if (typeof process !== "undefined" && process !== null) {
          return exit_stub.calledOnce.should.be["true"];
        }
      }).should.eventually.be.fulfilled;
    });
  });

  describe('request', function() {
    var call_id_stub, ms, request_2, request_3, response;
    ms = null;
    call_id_stub = null;
    request_2 = null;
    request_3 = null;
    response = null;
    beforeEach(function() {
      ms = new Miyo();
      request_3 = new ShioriJK.Message.Request();
      request_3.request_line.method = 'GET';
      request_3.request_line.protocol = 'SHIORI';
      request_3.request_line.version = '3.0';
      request_3.headers.set('Charset', 'UTF-8');
      request_3.headers.set('Sender', 'SSP');
      request_2 = new ShioriJK.Message.Request();
      request_2.request_line.method = 'GET Version';
      request_2.request_line.protocol = 'SHIORI';
      request_2.request_line.version = '2.6';
      request_2.headers.set('Charset', 'UTF-8');
      request_2.headers.set('Sender', 'SSP');
      response = new ShioriJK.Message.Response();
      response.status_line.code = 200;
      response.status_line.protocol = 'SHIORI';
      response.status_line.version = '3.0';
      response.headers.set('Charset', 'UTF-8');
      response.headers.set('Sender', 'SSP');
      response.headers.set('Value', 'test response');
      call_id_stub = sinon.stub(ms, 'call_id');
      call_id_stub.returns();
      call_id_stub.withArgs('OnTest').returns('test');
      call_id_stub.withArgs('OnTestResponse').returns(response);
      return call_id_stub.withArgs('OnTestThrow').throws('test throw');
    });
    it('should make bad request on SHIORI/2.x', function() {
      return ms.request(request_2).then(function(res) {
        return ("" + res).should.be.equal(ms.make_bad_request().toString());
      }).should.eventually.be.fulfilled;
    });
    it('should make response on entry that returns value', function() {
      request_3.headers.set('ID', 'OnTest');
      return ms.request(request_3).then(function(res) {
        return ("" + res).should.be.equal(ms.make_value('test').toString());
      }).should.eventually.be.fulfilled;
    });
    it('should return response on entry that returns response object', function() {
      request_3.headers.set('ID', 'OnTestResponse');
      return ms.request(request_3).then(function(res) {
        return ("" + res).should.be.equal(response.toString());
      }).should.eventually.be.fulfilled;
    });
    return it('should make internal server error on entry that throws', function() {
      request_3.headers.set('ID', 'OnTestThrow');
      return ms.request(request_3).then(function(res) {
        var error;
        try {
          call_id_stub('OnTestThrow');
        } catch (_error) {
          error = _error;
        }
        return ("" + res).should.be.equal(ms.make_internal_server_error(error).toString());
      }).should.eventually.be.fulfilled;
    });
  });

}).call(this);
