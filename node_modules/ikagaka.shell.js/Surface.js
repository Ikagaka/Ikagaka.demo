// Generated by CoffeeScript 1.7.1
var Surface;

Surface = (function() {
  var $, Promise, _;

  $ = window["Zepto"];

  _ = window["_"];

  Promise = window["Promise"];

  function Surface(element, scopeId, surfaceName, surfaces) {
    var srf;
    this.element = element;
    this.scopeId = scopeId;
    this.surfaceName = surfaceName;
    this.surfaces = surfaces;
    srf = this.surfaces.surfaces[surfaceName];
    this.baseSurface = srf.baseSurface;
    this.regions = srf.regions || {};
    this.animations = srf.animations || {};
    this.bufferCanvas = SurfaceUtil.copy(this.baseSurface);
    this.stopFlags = [];
    this.layers = [];
    this.destructed = false;
    this.talkCount = 0;
    $(this.element).on("click", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("dblclick", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnDoubleMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousemove", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousedown", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mouseup", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("IkagakaTalkEvent", (function(_this) {
      return function(ev) {
        _this.talkCount++;
        return Object.keys(_this.animations).filter(function(name) {
          return _this.animations[name].interval === "talk";
        }).forEach(function(name) {
          return _this.play(Number(_this.animations[name].is));
        });
      };
    })(this));
    Object.keys(this.animations).forEach((function(_this) {
      return function(name) {
        var animationId, interval, n, pattern, talkCount, tmp, _is, _ref;
        _ref = _this.animations[name], _is = _ref.is, interval = _ref.interval, pattern = _ref.pattern;
        animationId = Number(_is);
        interval = interval || "";
        tmp = interval.split(",");
        interval = tmp[0];
        n = Number(tmp.slice(1).join(","));
        switch (interval) {
          case "sometimes":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 2);
          case "rarely":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 4);
          case "random":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "periodic":
            return Surface.periodic((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "always":
            return Surface.always(function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            });
          case "runonce":
            return _this.play(animationId, function() {});
          case "never":
            break;
          case "bind":
            break;
          case "yen-e":
            return $(_this.element).on("IkagakaYenEEvent", function(ev) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId);
              }
            });
          case "talk":
            talkCount = 0;
            return $(_this.element).on("IkagakaTalkEvent", function(ev) {
              talkCount++;
              if (!_this.destructed && !_this.stopFlags[animationId] && talkCount % n === 0) {
                return _this.play(animationId);
              }
            });
          default:
            if (/^bind(?:\+(\d+))/.test(interval)) {

            }
            return console.error(_this.animations[name]);
        }
      };
    })(this));
    this.render();
  }

  Surface.prototype.destructor = function() {
    SurfaceUtil.clear(this.element);
    $(this.element).off();
    this.destructed = true;
    this.layers = [];
    return void 0;
  };

  Surface.prototype.render = function() {
    var elements, srfs, util, util2;
    srfs = this.surfaces.surfaces;
    elements = this.layers.reduce(((function(_this) {
      return function(arr, layer) {
        var hits, surface, type, x, y;
        if (!layer) {
          return arr;
        }
        surface = layer.surface, type = layer.type, x = layer.x, y = layer.y;
        if (surface === "-1") {
          return arr;
        }
        hits = Object.keys(srfs).filter(function(name) {
          return srfs[name].is === surface;
        });
        if (hits.length === 0) {
          return arr;
        }
        return arr.concat({
          type: type,
          x: x,
          y: y,
          canvas: srfs[hits[hits.length - 1]].baseSurface
        });
      };
    })(this)), []);
    SurfaceUtil.clear(this.bufferCanvas);
    util = new SurfaceUtil(this.bufferCanvas);
    util.composeElements([
      {
        "type": "base",
        "canvas": this.baseSurface
      }
    ].concat(elements));
    SurfaceUtil.clear(this.element);
    util2 = new SurfaceUtil(this.element);
    util2.init(this.bufferCanvas);
    return void 0;
  };

  Surface.prototype.play = function(animationId, callback) {
    var anim, hits;
    if (callback == null) {
      callback = function() {};
    }
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return Number(_this.animations[name].is) === animationId;
      };
    })(this));
    if (hits.length === 0) {
      setTimeout(callback);
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    anim.patterns.map((function(_this) {
      return function(pattern) {
        return function() {
          return new Promise(function(resolve, reject) {
            var a, animId, arr, b, match, surface, type, wait, __, _ref, _ref1, _ref2;
            surface = pattern.surface, wait = pattern.wait, type = pattern.type;
            if (/^start\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.play(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^stop\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.stop(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^alternativestart\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref[0], match = _ref[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.play(animId, function() {
                  return resolve();
                });
                return;
              }
            }
            if (/^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref1 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref1[0], match = _ref1[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.stop(animId);
                resolve();
                return;
              }
            }
            _this.layers[anim.is] = pattern;
            _this.render();
            _ref2 = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref2[0], a = _ref2[1], b = _ref2[2];
            if (b != null) {
              wait = _.random(Number(a), Number(b));
            }
            return setTimeout((function() {
              if (_this.destructed) {
                return reject();
              } else {
                return resolve();
              }
            }), wait);
          });
        };
      };
    })(this)).reduce((function(proA, proB) {
      return proA.then(proB);
    }), Promise.resolve()).then((function(_this) {
      return function() {
        return setTimeout(callback);
      };
    })(this))["catch"](function(err) {
      return console.error(err.stack);
    });
    return void 0;
  };

  Surface.prototype.stop = function(animationId) {
    this.stopFlags[animationId] = true;
    return void 0;
  };

  Surface.prototype.bind = function(animationId) {
    var anim, animIds, hits, interval, pattern;
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return Number(_this.animations[name].is) === animationId;
      };
    })(this));
    if (hits.length === 0) {
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    if (anim.patterns.length === 0) {
      return void 0;
    }
    interval = anim.interval;
    pattern = anim.patterns[anim.patterns.length - 1];
    this.layers[anim.is] = pattern;
    this.render();
    if (/^bind(?:\+(\d+))/.test(interval)) {
      animIds = interval.split("+").slice(1);
      animIds.forEach((function(_this) {
        return function(animId) {
          return _this.play(animId, function() {});
        };
      })(this));
    }
    return void 0;
  };

  Surface.prototype.unbind = function(animationId) {
    delete this.layers[animationId];
    return void 0;
  };

  Surface.processMouseEvent = function(ev, scopeId, regions, eventName, callback) {
    var detail, left, offsetX, offsetY, top, _ref;
    _ref = $(ev.target).offset(), left = _ref.left, top = _ref.top;
    offsetX = ev.pageX - left;
    offsetY = ev.pageY - top;
    $(ev.target).css({
      "cursor": "default"
    });
    if (Surface.isHit(ev.target, offsetX, offsetY)) {
      ev.preventDefault();
      detail = Surface.createMouseEvent(eventName, scopeId, regions, offsetX, offsetY);
      if (!!detail["Reference4"]) {
        $(ev.target).css({
          "cursor": "pointer"
        });
      } else {
        $(ev.target).css({
          "cursor": "default"
        });
      }
      callback($.Event('IkagakaSurfaceEvent', {
        detail: detail,
        bubbles: true
      }));
    }
    return void 0;
  };

  Surface.createMouseEvent = function(eventName, scopeId, regions, offsetX, offsetY) {
    var event, hits;
    event = {
      "ID": eventName,
      "Reference0": offsetX | 0,
      "Reference1": offsetY | 0,
      "Reference2": 0,
      "Reference3": scopeId,
      "Reference4": "",
      "Reference5": 0
    };
    hits = Object.keys(regions).slice().sort(function(a, b) {
      if (a.is > b.is) {
        return 1;
      } else {
        return -1;
      }
    }).filter(function(name) {
      var bottom, left, right, top, _ref;
      _ref = regions[name], name = _ref.name, left = _ref.left, top = _ref.top, right = _ref.right, bottom = _ref.bottom;
      return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
    });
    if (hits.length !== 0) {
      event["Reference4"] = regions[hits[hits.length - 1]].name;
    }
    return event;
  };

  Surface.random = function(callback, n) {
    var ms;
    ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / n) {
      ms++;
    }
    return setTimeout((function() {
      return callback(function() {
        return Surface.random(callback, n);
      });
    }), ms * 1000);
  };

  Surface.periodic = function(callback, n) {
    return setTimeout((function() {
      return callback(function() {
        return Surface.periodic(callback, n);
      });
    }), n * 1000);
  };

  Surface.always = function(callback) {
    return callback(function() {
      return Surface.always(callback);
    });
  };

  Surface.isHit = function(canvas, x, y) {
    var ctx, data, imgdata;
    ctx = canvas.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x, y);
    data = imgdata.data;
    return data[data.length - 1] !== 0;
  };

  return Surface;

})();
