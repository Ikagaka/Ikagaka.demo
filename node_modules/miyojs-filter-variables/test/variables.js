// Generated by CoffeeScript 1.8.0
(function() {
  var Miyo, MiyoFilters, chai, chaiAsPromised, expect, fs, sinon,
    __slice = [].slice;

  if (typeof require !== "undefined" && require !== null) {
    chai = require('chai');
  } else {
    chai = this.chai;
  }

  chai.should();

  expect = chai.expect;

  if (typeof require !== "undefined" && require !== null) {
    chaiAsPromised = require('chai-as-promised');
  } else {
    chaiAsPromised = this.chaiAsPromised;
  }

  chai.use(chaiAsPromised);

  if (typeof require !== "undefined" && require !== null) {
    sinon = require('sinon');
    Miyo = require('miyojs');
    MiyoFilters = require('../variables.js');
  } else {
    sinon = this.sinon;
    Miyo = this.Miyo;
    MiyoFilters = this.MiyoFilters;
  }

  if (typeof require !== "undefined" && require !== null) {
    fs = require('fs');
  } else {
    fs = this.fs;
  }

  describe('variables_initialize', function() {
    var entry, ms, request;
    ms = null;
    request = null;
    entry = null;
    beforeEach(function() {
      var filter, name;
      ms = new Miyo();
      for (name in MiyoFilters) {
        filter = MiyoFilters[name];
        ms.filters[name] = filter;
      }
      request = sinon.stub();
      return entry = {
        filters: ['variables_initialize'],
        argument: {
          value: 'dummy'
        }
      };
    });
    it('should return original argument', function() {
      return ms.call_filters(entry, null, '_load').should.eventually.be.deep.equal(entry.argument);
    });
    return it('should define variables and methods', function() {
      return ms.call_filters(entry, null, '_load').then(function() {
        ms.variables.should.be["instanceof"](Object);
        ms.variables_temporary.should.be["instanceof"](Object);
        ms.variables_save.should.be["instanceof"](Function);
        return ms.variables_load.should.be["instanceof"](Function);
      });
    });
  });

  describe('variables_load', function() {
    var data, error, ms, promise, readFile, request;
    ms = null;
    request = null;
    readFile = null;
    error = undefined;
    data = undefined;
    promise = null;
    beforeEach(function() {
      var entry, filter, name;
      error = undefined;
      data = undefined;
      ms = new Miyo();
      for (name in MiyoFilters) {
        filter = MiyoFilters[name];
        ms.filters[name] = filter;
      }
      entry = {
        filters: ['miyo_require_filters', 'property_initialize', 'variables_initialize'],
        argument: {
          miyo_require_filters: ['property'],
          property_initialize: {
            handlers: ['coffee', 'jse', 'js']
          }
        }
      };
      promise = ms.call_filters(entry, null, '_load');
      request = sinon.stub();
      return readFile = sinon.stub(fs, 'readFile', function() {
        var args, callback;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        callback = args[args.length - 1];
        if (callback instanceof Function) {
          return callback(error, data);
        }
      });
    });
    afterEach(function() {
      return readFile.restore();
    });
    it('should read', function() {
      var variables;
      variables = {
        "var": 23,
        nest: {
          a: 1,
          b: 1
        }
      };
      data = JSON.stringify(variables);
      return promise.then(function() {
        return ms.variables_load('test/variables.json');
      }).then(function() {
        return ms.variables.should.be.deep.equal(variables);
      });
    });
    it('should called from filter', function() {
      var entry, variables;
      variables = {
        "var": 23,
        nest: {
          a: 1,
          b: 1
        }
      };
      data = JSON.stringify(variables);
      entry = {
        filters: ['variables_load'],
        argument: {
          variables_load: {
            file: 'test/variables.json'
          }
        }
      };
      return promise.then(function() {
        return ms.call_filters(entry, null, '_load');
      }).then(function() {
        return ms.variables.should.be.deep.equal(variables);
      });
    });
    it('should reject on fs error', function() {
      error = 'error test';
      return promise.then(function() {
        return ms.variables_load('test/variables.json');
      }).should.eventually.rejectedWith('error test');
    });
    it('filter should call error callback on fs error', function() {
      var entry;
      error = 'error test';
      entry = {
        filters: ['variables_load'],
        argument: {
          variables_load: {
            file: 'test/variables.json',
            'error.jse': 'stash.error'
          }
        }
      };
      return promise.then(function() {
        return ms.call_filters(entry, null, '_load');
      }).then(function(argument) {
        return argument.should.deep.equal(error);
      });
    });
    it('filter should return argument if no error callback on fs error', function() {
      var entry;
      error = 'error test';
      entry = {
        filters: ['variables_load'],
        argument: {
          variables_load: {
            file: 'test/variables.json'
          }
        }
      };
      return promise.then(function() {
        return ms.call_filters(entry, null, '_load');
      }).then(function(argument) {
        return argument.should.deep.equal(entry.argument);
      });
    });
    return it('should reject with filter no argument', function() {
      var entry;
      entry = {
        filters: ['variables_load']
      };
      return promise.then(function() {
        return ms.call_filters(entry, null, '_load');
      }).should.eventually.rejectedWith(/argument.variables_load.file undefined/);
    });
  });

  describe('variables_save', function() {
    var error, ms, promise, request, writeFile;
    ms = null;
    request = null;
    writeFile = null;
    error = undefined;
    promise = null;
    beforeEach(function() {
      var entry, filter, name;
      ms = new Miyo();
      for (name in MiyoFilters) {
        filter = MiyoFilters[name];
        ms.filters[name] = filter;
      }
      entry = {
        filters: ['miyo_require_filters', 'property_initialize', 'variables_initialize'],
        argument: {
          miyo_require_filters: ['property'],
          property_initialize: {
            handlers: ['coffee', 'jse', 'js']
          }
        }
      };
      promise = ms.call_filters(entry, null, '_load');
      request = sinon.stub();
      return writeFile = sinon.stub(fs, 'writeFile', function() {
        var args, callback;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        callback = args[args.length - 1];
        if (callback instanceof Function) {
          return callback(error);
        }
      });
    });
    afterEach(function() {
      return writeFile.restore();
    });
    it('should write', function() {
      return promise.then(function() {
        ms.variables = {
          "var": 23,
          nest: {
            a: 1,
            b: 1
          }
        };
        return ms.variables_save('test/variables.json');
      }).then(function() {
        writeFile.calledOnce.should.be["true"];
        return writeFile.firstCall.calledWith('test/variables.json', JSON.stringify(ms.variables, 'utf8'));
      });
    });
    it('should called from filter', function() {
      return promise.then(function() {
        var entry;
        ms.variables = {
          "var": 23,
          nest: {
            a: 1,
            b: 1
          }
        };
        entry = {
          filters: ['variables_save'],
          argument: {
            variables_save: {
              file: 'test/variables.json'
            }
          }
        };
        return ms.call_filters(entry, null, '_unload');
      }).then(function() {
        writeFile.calledOnce.should.be["true"];
        return writeFile.firstCall.calledWith('test/variables.json', JSON.stringify(ms.variables, 'utf8'));
      });
    });
    it('should reject on fs error', function() {
      error = 'error test';
      return promise.then(function() {
        ms.variables = {
          "var": 23
        };
        return ms.variables_save('test/variables.json');
      }).should.eventually.rejectedWith('error test');
    });
    it('filter should call error callback on fs error', function() {
      var entry;
      error = 'error test';
      entry = {
        filters: ['variables_save'],
        argument: {
          variables_save: {
            file: 'test/variables.json',
            'error.jse': 'stash.error'
          }
        }
      };
      return promise.then(function() {
        ms.variables = {
          "var": 23
        };
        return ms.call_filters(entry, null, '_unload');
      }).then(function(argument) {
        return argument.should.deep.equal(error);
      });
    });
    it('filter should return argument if no error callback on fs error', function() {
      var entry;
      error = 'error test';
      entry = {
        filters: ['variables_save'],
        argument: {
          variables_save: {
            file: 'test/variables.json'
          }
        }
      };
      return promise.then(function() {
        ms.variables = {
          "var": 23
        };
        return ms.call_filters(entry, null, '_unload');
      }).then(function(argument) {
        return argument.should.deep.equal(entry.argument);
      });
    });
    return it('should reject with filter no argument', function() {
      return promise.then(function() {
        var entry;
        entry = {
          filters: ['variables_save']
        };
        return ms.call_filters(entry, null, '_unload');
      }).should.eventually.rejectedWith(/argument.variables_save.file undefined/);
    });
  });

}).call(this);
